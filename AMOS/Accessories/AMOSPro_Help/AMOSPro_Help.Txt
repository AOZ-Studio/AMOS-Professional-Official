The young super TV star has this to say about his football team:

Queens Park Rangers are a super team! They'll never win anything though...

Francois once let the alarm off at Europress and almost got arrested.

The fatest First Direct coloured Cat!

The real programmer!

The most patient French Woman in the world!

The only man to burn a hole in a QWERTY keyboard.

Sick and tired of the help file but proud of it.

The world's best programmer!

Double Precision info

We only got Double Precision working very near the end of the project, too
late for the User Guide! So there's something else you need to know:

Single and Double don't mix!
----------------------------

Imagine you've just loaded in your favourite sine scroller and want to make
it even more accurate with the new Double Precision feature of AMOS Pro.
To do this you need to add the SET DOUBLE PRECISION command at the top of
your program and then (and this is the new bit), you need to retokenise the
program using the accessory which is available from the User menu.

The retokeniser changes all the single precision numbers in your program
into double precision. This needs to be done because single to double
precision conversions would have to happen during your program. These
conversions are not very accurate and take longer to work out. So it's
best to have the same precision throughout your program. You could run
a mixture of the two precisions but you'll lose accuracy.

Configuration info

When you installed AMOS Professional, the installer set up options within
the configuration that benefits your memory situation. For example the Undo
buffers are set low on a 1 meg machine.

So don't use a 1 meg AMOS Pro disc on a bigger machine - just reinstall it.

Compiler and 3D Extensions

If you are a registered AMOS Compiler and/or AMOS 3D user you'll be wanting
to use AMOS Professional with these two extensions. It was our plan to have
the two intergrated for Pro's release. Sadly though we've had technical
problems and the extensions are currently not compatible.

By the end of October we will have sorted this out and an update will be made
availble. So call Europress at the start of November for information on how
to upgrade your Compiler and/or 3D.

        Tel: 0625 859333   International +44 625 559333
        Fax: 0625 879962   International +44 625 879962

Credits

                Main Programmer      Francois Lionet
                User Guide Author    Mel Croucher
                Technical Author     Stephen Hill
                Demo Programmer      Ronnie Simpson
                Project Manager      Richard Vanner

Special thanks to:Alex Blagg, David Ratcliffe, Barney, Richard Peacock, Alexa
Czechowski, Anna Donaldson, Stuart Davis, Donald Anderson, Peter Hickman,
Dominic Ramsey, Stoo Cambridge, Darren Ithell, Syntex, Jason Holborn, Tony
Dillon, Phil South, Len Tucker and everyone else who played a part in creating
this monster!

Programmers and Artists Wanted!

Europress Software is always on the look-out for talented programmers and
graphic artists. The productivity discs are examples of work created by
freelancers, can you do better? Send us examples of your work we'd be
delighted to evaluate it.

Bugs in AMOS Professional? Surely not! Well we don't think there are but
they'll probably raise their ugly heads when your using Pro. If you do
discover a bug or problem then please, please, please let us know. We make
it our number 1 goal to have our software bug free.

If you find a bug send the program that creates the problem on disc to
Richard Vanner. Comment the program so that he can easily home in on the
offending command. Even try running the program through the Monitor which
might pin point the problem for you.

Happy Programming

Procedures

The procedures we've supplied on Productivity disc 2 are the result of a
competition we ran in the very supportive Amiga Shopper magazine. AMOS users
were asked to send in useful procedures which could be supplied as a sort
of library. We thank all those who took part and believe that the ones we
decided to go with will suprise you all. Check out the Plasma and Sine
Scroller demos - the're fun.

Perhaps you have better procedures? Why not share them, the AMOS PD library
would be delighted to create Procedure discs.

Memory Considerations - 1 meg users of AMOS Professional

AMOS Professional does its best to give you as much available memory as
possible. But at the end of the day AMOS Professional is a huge program with
many memory requirements. So we'll point you in the right direction by
offering the following advice:


* A Multitasking machine in its own nature needs to have spare memory to
  operate properly. So you must ensure that at least 32k memory is left free
  for the system's own needs. Trying to grab all the memory is just too
  risky.

* AMOS Professional has a built-in low memory protection system that helps you
  avoid using up memory.

  If you find the Editor's drop down menus cannot be accessed, it's because
  there's less than 72k available and AMOS Professional needs more to open
  them. If you let this happen you are still able to use the keyboard
  short-cuts.

  AMOS Professional also has a memory grabber. When Pro detects less than 72k
  is available it will erase the following until more than 72k is freed:

        - the Default screen (if open).
        - any open maths libraries (if they are not needed anymore)
        - the Undo buffers
        - the directory Stored in the File Selector

  If Pro can than access more than 72k it will allow the menus to be opened.

* You may find that some programs will fail under AMOS Pro and yet work fine
  in old AMOS. Obviously AMOS Pro's new Editor and features take up more
  memory. So to free up memory when your programs run try these techniques:

   - The Close Editor command will free a considerable amount of memory but
     will still leave you with a 50k overhead compared to old AMOS.

   - Using the new Kill Editor command will free so much memory that you'll
     have 32k more to play with than was possible in old AMOS. The bad news
     is you'll have to wait for the editor to load after each run.

     Some programs that use Kill Editor may ask for lots of memory by
     reserving banks and opening screens. Once the program has finished, AMOS
     Pro attempts to reload the Editor. It will first ask you to insert the
     System disc so that it can find the Editor files and then attempt to
     load it.

     If this fails due to low memory, AMOS Pro will clear all variables, the
     screens etc.

     If it still fails a small requester will appear that asks if you want to
     erase the memory banks - this should be plenty for the editor to load,
     if not you'll be dumped into the Workbench.

     So when you program in a low memory state, ensure your program erases the
     banks before going back to the editor.

A memory expansion would be the best solution if you find yourself always
programming around low memory conditions!

Losing the File Selector Stored Directories
-------------------------------------------
If you find the Store option has been erased this will be due to a memory
flush that occured earlier in your programming.


BORDER
{[RAMOSPro_Examples:Examples/H-3/Help_31.AMOS,0,4]Border}

Sets the border style of the current text window.

        Border style,paper,pen

style  can  range  from  1 to 16, but currently only styles 1 through 3 are
defined for your use.

END
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]End}

Exits from the program.

      End
FREE
{[RAMOSPro_Examples:Examples/H-6/Help_64.amos,0,4]=Free}

Returns the number of bytes of FREE memory available to hold variables.

        Print Free

FREEZE
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Freeze}

Freezes  all  object  movements  at  their  present  position.  They can be
restarted again using UNFREEZE.

        Freeze

INPUT
{[RAMOSPro_Examples:Examples/H-6/Help_63.AMOS,0,4]Input}

Loads information into one or more variables.

        Input variable list
        Input "prompt";variable list

REM
{[RAMOSPro_Examples:Examples/H-4/Help_48.amos,0,4]Rem}

Rem  is  a little REMark statement included in your programs that helps you
REMember  something.   The text you use after a REM statement is ignored by
the program.  The apostrophe character can also be used instead of REM.

        Rem This is where I hid my old socks data
        ' And this is a rem statement too
UNFREEZE
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Unfreeze}

Starts your objects moving again after you've suspended them with FREEZE.

        UNfreeze
X GR
{[RAMOSPro_Examples:Examples/H-0/Help_6.AMOS,0,4]=X Gr}

Returns the X coordinate of the invisible graphics cursor.

        cx=Xgr
Y GR
{[RAMOSPro_Examples:Examples/H-0/Help_6.AMOS,0,4]=Y Gr}

Returns the Y coordinate of the invisible graphics cursor.

       cy=Ygr

Main Menu

             {[IHelphelp    ,4,3] Using Help             }  {[IHelpAudio   ,4,3] Audio                  }
             {[IHelpkeyHelp ,4,3] Editor                 }  {[IHelpInterface ,4,3] AMOS Interface         }
             {[IHelpDirect  ,4,3] Direct mode            }  {[IHelpIO    ,4,3] Input/Output           }
             {[IHelpSyntax  ,4,3] Syntax conventions     }  {[IHelpAmigaDos ,4,3] AmigaDos               }
             {[IHelpBasics  ,4,3] Basics of AMOS         }  {[IHelpDebug   ,4,3] Debugging              }
             {[IHelpScreens ,4,3] Screen control         }  {[IHelpMC      ,4,3] Machine code           }
             {[IHelpObjects ,4,3] Object control         }  {[IHelpTables  ,4,3] Tables                 }


                                {[IHelpinfo    ,4,3] Latest News}

Using Help
Welcome  to  the amazing AMOS Professional Help System.  This contains full
details  of all 700+ AMOS commands.  So if you get stuck, help will only be
a keypress away!

You  can  use  this  system in a variety of ways.  The easiest option is to
simply position the Editor`s cursor over the first character of any command
you  are  unsure  of, and hit the Help key straight from the keyboard.  The
Help  program  will  now  load  into memory, and you`ll be presented with a
quick explanation of the command in a special `help window`.

If  the  information  is  longer  than  a  single screen it can be scrolled
through  the  window  using either the Up/Down arrows from the keyboard, or
via  the arrow icons to the top right of the window.  You can also drag the
window through the text using the scroll bar along the right.

Along the top of the window there are four icons.

The X icon closes the help window and returns you to your basic program.

Prev.Page flicks back to the most recently displayed help screen.

Main Menu presents you with a full list of the available help topics.

Print makes a hardcopy of the current help screen onto a printer for future
reference.

The individual help menus are formed  using a series of buttons which can be
selected  using  the Left Mouse key  as you`d expect.  Some buttons move you 
directly to the  explanation of a particular command, whereas others present
you with a complete menu in their own right. Here`s an example:

                        {[IHelpItem1,4,3] Help Example 1                }
                        {[IHelpItem2,4,3] Help Example 2                }
                        {[IHelpItem3,4,3] Help Example 3                }

Some  of  these  menus have been permanently assigned to the main Help menu
from the Editor window.  These can be brought up by simply highlighting the
menu item with the mouse.

Try selecting one of these buttons with the Left mouse key.  See you there!

We`ll  finish  off  this tutorial with a brief list of all the ways you can
get help from AMOS Professional.

* Pressing the Help Key when you`ve positioned the cursor over an AMOS command

* Hitting F5 from the keyboard

* Selecting the `H` icon from the top of the Editor window.

* Selecting a menu item from the Help menu.

Item 1
This is an example of a help item. 

Many items also have an associated example program.  This is indicated by a
line such as:

{[RAMOSPro_Examples:Examples/H-0/Help_1.AMOS,0,4] Help Example 1 }

When  you  click  on the heighlighted text, you will be given the option to
load  the  selected  program  into  a  new listing window and return to the
Editor.

Now  click  on  the Prev.Page button at the top of this window to return to
the tutorial screen.

Item 2
This is another example of a help item.

Many items also have an associated example program.  This is indicated by a
line such as:

{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4] Help Example 2 }

When  you  click  on the heighlighted text, you will be given the option to
load  the  selected  program  into  a  new listing window and return to the
Editor.

Now click on the Prev.Page button at the top of this window to return to the
tutorial screen.

Item  3 
This is the third example of a helpitem.

Many items also have an associated example program.  This is indicated by a
line such as:

{[RAMOSPro_Examples:Examples/H-0/Help_3.AMOS,0,4] Help Example 3 }

When  you  click  on the heighlighted text, you will be given the option to
load  the  selected  program  into  a  new listing window and return to the
Editor.

Now click on the Prev.Page button at the top of this window to return to the
tutorial screen.


The Basics of AMOS Professional

                        {[IHelpBare    ,4,3] The Bare Bones               }
                        {[IHelpStrings ,4,3] Strings                      }
                        {[IHelpMaths   ,4,3] Maths                        }
                        {[IHelpCS      ,4,3] Control Structures           }
                        {[IHelpProcs   ,4,3] Procedures                   }
                        {[IHelptext    ,4,3] Text                         }
                        {[IHelpWindows ,4,3] Windows                      }
                        {[IHelpFonts   ,4,3] Fonts                        }
                        {[IHelpMouse   ,4,3] The mouse and joystick ports }
                        {[IHelpMembank ,4,3] Memory banks                 }
                        {[IHelpArray   ,4,3] Array Operations             }
                        {[IHelpProgram ,4,3] Program Run commands         }
                        {[IHelpMemcons ,4,3] Memory Conservation          }
                        {[IHelpMisc    ,4,3] Miscellaneous commands       }
Screen Control

                        {[IHelpSetup   ,4,3] Setting up screens           }
                        {[IHelpSeffect ,4,3] Screen effects               }
                        {[IHelpGraphic ,4,3] Graphics                     }
                        {[IHelpMenus   ,4,3] Menus                        }
                        {[IHelpZones   ,4,3] Screen Zones                 }
Object Control

                        {[IHelpHardSP  ,4,3] Hardware Sprites             }
                        {[IHelpBobs    ,4,3] Blitter objects              }
                        {[IHelpUpdate  ,4,3] Updating objects             }
                        {[IHelpCollide ,4,3] Detecting collisions         }
                        {[IHelpIFFanim ,4,3] IFF anim                     }
                        {[IHELPAMAL    ,4,3] AMAL                         }
                        {[IHELPICBK    ,4,3] Icons and Blocks             }

Audio

                        {[IHelpMusic   ,4,3] Music                        }
                        {[IHelpSound   ,4,3] Sound Effects                }
                        {[IHelpSpeech  ,4,3] Speech                       }
                        {[IHelpSamples ,4,3] Samples                      }
                        {[IHelpTracker ,4,3] Tracker                      }
                        {[IHelpMed     ,4,3] MED                          }

Control Structures

                      {[IDO       ,4,3] Do       } {[IEXIT IF  ,4,3] Exit If  } {[IPOP      ,4,3] Pop      }
                      {[IELSE     ,4,3] Else     } {[IFOR      ,4,3] For      } {[IREPEAT   ,4,3] Repeat   }
                      {[IELSE IF  ,4,3] Else If  } {[IGOSUB    ,4,3] Gosub    } {[IRETURN   ,4,3] Return   }
                      {[IEND IF   ,4,3] End If   } {[IGOTO     ,4,3] Goto     } {[ISTEP     ,4,3] Step     }
                      {[IEVERY    ,4,3] Every    } {[IIF       ,4,3] If       } {[ITHEN     ,4,3] Then     }
                      {[IEVERY ON ,4,3] Every On } {[ILOOP     ,4,3] Loop     } {[IUNTIL    ,4,3] Until    }
                      {[IEVERY OFF,4,3] Every Off} {[INEXT     ,4,3] Next     } {[IWEND     ,4,3] Wend     }
                      {[IEXIT     ,4,3] Exit     } {[ION       ,4,3] On       } {[IWHILE    ,4,3] While    }
DO
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]Do}

Acts  as  a  marker  to  which a matching LOOP statement can return.  Press
[Ctrl]+[C] to break out of one of these loops.

        Do : Print "forever" : Loop
ELSE
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Else}

Chooses between alternative actions in an IF...THEN structure.

        If condition Then statement1 Else statement2

ELSE IF
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Else If}

This is used inside an IF..ENDIF or IF..ELSE..ENDIF structure.  It performs
a  test,  and  if  it's true, executes all the AMOS commands until the next
ELSEIF, ELSE or ENDIF statement.

        If A=1
           Print "A=1"
        Else If A=2
           Print "A=2"
        Else If A=3
           Print "A=3"
        Else
           Print "Other values..."
        End If

Note that you CAN'T use an ELSEIF between the ELSE and ENDIF section.
END IF
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Endif}

ENDs an IF condition inside a structured test.

        If test : Goto Label1 : Else Goto Label2 : Endif
EVERY
{[RAMOSPro_Examples:Examples/H-1/Help_14.AMOS,0,4]Every}

Calls  a  named  subroutine  or  procedure at regular intervals.  There are
several different forms of this command to choose from:

        Every n Gosub label

Executes the gosub after n fiftieths of a second.

        Every n Proc name

Calls a procedure every n ticks
EVERY ON
{[RAMOSPro_Examples:Examples/H-1/Help_14.AMOS,0,4]Every On}

Used  to  start  up  the  ON  EVERY system.  You'll also need to perform it
directly  before  leaving  your  procedure  or  gosub.  Otherwise the EVERY
system will stop after the first call.

        Every On
EVERY OFF
{[RAMOSPro_Examples:Examples/H-1/Help_14.AMOS,0,4]Every Off}

Turns off the ON..EVERY system.

        Every Off
EXIT
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]Exit}

Jumps   out   of   a   program   loop  created  by  DO...LOOP,  FOR...NEXT,
REPEAT...UNTIL  or  WHILE...WEND.   If  you  omit  the number of loops, the
innermost loop will be terminated automatically.

        Exit
        Exit loopnumbers

EXIT IF
{[RAMOSPro_Examples:Examples/H-1/Help_12.AMOS,0,4]Exit If}

Exits  from  a program loop if the condition is TRUE.  Allowable loop types
include DO..LOOP, FOR..NEXT and REPEAT..UNTIL.

        Exit If condition
        Exit if condition,loopnumbers
FOR
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]For}

FOR  is  used  to  kick  off  the  repetition of a section of program FOR a
specific  number of times.  It is used with the distance command TO and the
counting command NEXT.

        For counter=start To end
        Next
GOSUB
{[RAMOSPro_Examples:Examples/H-0/Help_3.AMOS,0,4]Gosub}

Jumps to subroutine in your program.  At the end of your routine you should
use  a  RETURN  statement  to  return to the next instruction after the
GOSUB.

        Gosub linenumber : Rem jump to subroutine at linenumber
        Gosub label : Rem jump to this AMOS Professional label
        Gosub expression : Rem jump to resulting label/line
GOTO
{[RAMOSPro_Examples:Examples/H-0/Help_3.AMOS,0,4]Goto}

Instructs the program to GO TO a specified new line number or label.

        Goto label
        Goto linenumber
        Goto expression
IF
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]If}

Selects between one of two actions, depending on a condition.

        If conditions Then statements

More advanced IF instructions can be set up that choose between alternative
actions,  using  AND, OR and ELSE.  ENDIF is used to terminate this sort of
structured test.

        If test : Goto Label : Else Goto Label2 : End If
LOOP
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]Loop}

Acts as the partner to a DO command, creating a repetitive LOOP.

       Do
           Print "Eternity"
       Loop
NEXT
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Next}

is the counting command that partners FOR, to repeat a section of program
a specific number of times.

       For x=1 To 100 : Print "Professional" : Next x
ON
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]On}

Jumps to a particular line or procedure, depending ON the contents of a 
variable.

ON can be used in conjunction with GOTO, GOSUB, or PROC

{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]        On variable Goto  label1,label2...}
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]        On variable Gosub label1,label2...}
{[RAMOSPro_Examples:Examples/H-1/Help_12.AMOS,0,4]        On variable Proc  proc1, proc2 ...}
POP
{[RAMOSPro_Examples:Examples/H-0/Help_3.AMOS,0,4]Pop}

Pops the RETURN value out of a Gosub and allows you to leave it in any
way you like:

        Pop : Goto ANYWHERE
REPEAT
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]Repeat}

Kicks off a program loop that REPEATs UNTIL a condition is satisfied.

        Repeat
              list of statements
        Until condition
RETURN
{[RAMOSPro_Examples:Examples/H-0/Help_3.AMOS,0,4]Return}

Exits  from  a subroutine and RETURNs to the AMOS Pro instruction after the
original GOSUB.  Each Gosub statement can have more than one Return command
at different places in the routine.

        Return
STEP
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Step}

Controls  the  size  of any STEPs inside a FOR...NEXT loop.  Normally steps
are  counted  off  in units of one at a time, but you can choose any number
you want for the size of step.

        For x=firstnumber To lastnumber STEP stepnumber
THEN
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Then}

Acts as a partner to an IF in a logical choice between alternative actions.

       If condition Then statement
UNTIL
{[RAMOSPro_Examples:Examples/H-1/Help_13.AMOS,0,4]Until}

Keeps a REPEAT loop going UNTIL a condition has been satisfied.

        Repeat
              list of statements
        Until condition
WHILE
{[RAMOSPro_Examples:Examples/H-1/Help_12.AMOS,0,4]While}

Marks  the  beginning  of  a  loop used to repeat a section of your program
WHILE  a  condition  remains  true.   If the condition does not result in a
value of -1 for "true", then the loop will be stopped, and the program will
go on to the next instruction.

        While condition
                list of statements
        Wend
WEND
{[RAMOSPro_Examples:Examples/H-1/Help_12.AMOS,0,4]Wend}

Marks  the  end  of a loop used to repeat a section of your program WHILE a
condition  remains true.  If the condition does not result in a value of -1
for  "true",  then  the loop will be stopped, and the program will go on to
the next instruction.

        While condition
                list of statements
        Wend

AMOS Interface

                {[IARRAY          ,4,3] =Array              } {[IEDIALOG            ,4,3] =Edialog            }
                {[IDIALOG         ,4,3] =Dialog             } {[IRDIALOG            ,4,3] =Rdialog            }
                {[IDIALOG BOX     ,4,3] =Dialog Box         } {[IRDIALOG$           ,4,3] =Rdialog$           }
                {[IDIALOG CLOSE   ,4,3] Dialog Close        } {[IRESOURCE$          ,4,3] =Resource$          }
                {[IDIALOG CLR     ,4,3] Dialog Clr          } {[IRESOURCE BANK       ,4,3] Resource Bank       }
                {[IDIALOG FREEZE  ,4,3] Dialog Freeze       } {[IRES_EDIT            ,4,3] The Resource Editor }
                {[IDIALOG OPEN    ,4,3] Dialog Open         } {[IRESOURCE SCREEN OPEN,4,3] Resource Screen Open}
                {[IDIALOG RUN     ,4,3] =Dialog Run         } {[IRESOURCE UNPACK     ,4,3] Resource Unpack     }
                {[IDIALOG UNFREEZE,4,3] Dialog Unfreeze     } {[IVDIALOG            ,4,3] =Vdialog            }
                {[IDIALOG UPDATE  ,4,3] Dialog Update       } {[IVDIALOG$           ,4,3] =Vdialog$           }

                           {[IHelpIntins     ,4,3]   Internal  Commands   }
ARRAY
{[RAMOSPro_Tutorial:Tutorials/Interface/Sliders.AMOS,0,4]=Array}

Returns the address in memory of the first item in your array.

        address=ARRAY(list(0))
        address=ARRAY(list$(0))
        address=ARRAY(list#(0))

list is the name of your array, and can contain any data you like.

DIALOG
{[RAMOSPro_Tutorial:Tutorials/Interface/Communication.AMOS,0,4]Dialog}

Checks whether the user has selected one of the options from a control panel.

        button=Dialog(channel)

The return value can take one of several values.

=0   There has been no input from the user since the last selection.
>0   Holds the number of the last button highlighted by the user.
DIALOG BOX
{[RAMOSPro_Tutorial:Tutorials/Interface/Simple_requester.AMOS,0,4]=Dialog Box}

Displays  a  requestor  or  dialogue  box  on  the  screen  using  a set of
instructions from an Interface command string or resource bank.

        button=Dialog Box(Interface$)
        button=Dialog Box(program)

Interface$ is a normal AMOS string containing your Interface program.

program is the number of an Interface program from the resource bank.

        button=Dialog Box(Interface$,p0)
        button=Dialog Box(program,p0)
        button=Dialog Box(Interface$,p0,p1$)
        button=Dialog Box(program,p0,p1$)

p0  contains  an  optional value which is loaded straight into the internal
variable  array.   It  can  be  accessed  using  the 0 VA command from your
dialogue box or requestor.

p1$ holds an optional string value which will be forwarded to your 
Interface program.

It will be saved as item 1 of the variable array (1 VA).

        button=Dialog Box(Interface$,p0,p1$,x,y)
        button=Dialog Box(program,p0,p1$,x,y)

x,y  positions  the dialogue box on the screen using a couple of coordinate
values.  These coordinates can be overridden using a BA command inside your
Interface program.

Note: If you want your Interface program to wait for user's input,you MUST 
include a RUn command before your final EXit;
DIALOG CLOSE
{[RAMOSPro_Tutorial:Tutorials/Interface/Communication.AMOS,0,4]Dialog Close}

Closes  one  or  more  dialogue  channels on the screen.  If your Interface
program includes an SA command, the original background areas will be pasted
neatly back onto the display before it leaves.

        Dialog Close

Closes all dialogue channels.

        Dialog Close channel

Closes just a single channel.
DIALOG CLR
Erases all zones and totally shuts down your dialog box, leaving the channel
still open. You can now re-run your Interface program from the start using a
further call to the DIALOG RUN command as normal. 

As always, if the background area has been saved using the SA option, it will
be restored to it's original position.

        Dialog Clr channel

channel holds number of the channel to be cleared.
DIALOG FREEZE
Freezes all input from one or more active dialog channels.

        Dialog Freeze

Suspends all current dialogue boxes.

        Dialog Freeze channel

Stops just a single dialogue routine.

DIALOG OPEN
{[RAMOSPro_Tutorial:Tutorials/Interface/Communication.AMOS,0,4]Dialog Open}

Opens up a "communications channel" to your new AMOS interface program.

        Dialog Open channel,Interface$
        Dialog Open channel,program

channel is the number of the channel to open, starting from one.

Interface$  is  an AMOS string containing one or more Interface programs to
be  initialised.   If  your  string contains several programs, each routine
should begin with a LAbel instruction and end with an "EXit" command.

program  holds  the number of an Interface program installed in the resource
bank.  See the RESOURCE BANK command for details

        Dialog Open channel,Interface$,nvar
        Dialog Open channel,program,nvar

nvar  sets  the  size of the variable array used by your Interface program.
Each extra variable takes up 4 bytes of memory.

        Dialog Open channel,Interface$,nvar,buffer
        Dialog Open channel,program,nvar,buffer

buffer  sets  the  size  of  an internal memory area used by your Interface
programs.   As  a  default,  the  buffer is just 1k for each channel you've
defined,  but  if  your interface is very complex, you may need to increase
this value dramatically.

DIALOG RUN
{[RAMOSPro_Tutorial:Tutorials/Interface/Communication.AMOS,0,4]=Dialog Run}

Executes an Interface program from a dialogue channel which you've previously
set up with DIALOG OPEN.

        b=Dialog Run(channel)

Runs your Interface program.  If it doesn't contain a RunUntil instruction,
the dialogue will occur in the background.

        b=Dialog Run(channel,label)

label  starts  the  program  from a specific label in the Interface command
string.   If  it's  not  specified, the system will commence from the first
program in the list.

        b=Dialog Run(channel,label,x,y)

x,y  set  the  position  of  the control panel on the screen.  All graphics
coordinates will now be measured from this point.

Warning! 

If you've included a BAse command in your program, your new x,y coordinates
will be totally ignored.

DIALOG UNFREEZE
Used  after a DIALOG FREEZE to restart the dialog channel from the point it
left off.

        Dialog Unfreeze

Starts all suspended channels.

        Dialog Unfreeze channel

Activates a single channel.
DIALOG UPDATE
Forces AMOS Interface to redraw the contents of an active zone on the screen.

        Dialog Update channel,zone

channel the number of an active dialogue channel to be updated.

zone enters the number of the zone to be affected.

        Dialog Update channel,zone[,param1][,param2][,param3]

The effect of these parameters depends on the type of your zone.

Param 1:

Button       Enters a new position.
Active List  Sets the number of the first string displayed
Slider       Moves the slider
Digit        Replaces the existing number zone
Edit         Inserts a new string in the edit zone

Param 2:

Active List  Changes the currently selected string
Slider       Alters the size of the slider window 

Param3:

Active List  Sets the last element of the array that you can select.
Slider       Changes the "total" parameter

EDIALOG
Returns  the  position  of  an error in the current AMOS Interface program.
It's  used  after  a  TRAP or ON ERROR statement to isolate any problems in
your Interface routine.

         position=Edialog
RDIALOG
{[RAMOSPro_Tutorial:Tutorials/Interface/Editing_zones.AMOS,0,4]=Rdialog}

Reads the position of a particular button or selector.

        b=Rdialog(channel,zone)

channel is the number of a currently open Interface channel

zone specifies the button or zone to be tested.

        b=Rdialog(channel,zone,version)

If  you  omit  the  version number, RDIALOG will return the position of the
FIRST object you've defined with the current zone number.

RDIALOG$
{[RAMOSPro_Tutorial:Tutorials/Interface/Editing_zones.AMOS,0,4]=Rdialog$}

Returns  a  piece  of text assigned to a zone.  If your chosen zone doesn't
actually contain any text, you'll be presented with an empty string "".

        test$=RDIALOG$(channel,zone)

channel is the number of a currently open Interface channel

zone specifies the button or zone to be tested.

        test$=RDIALOG$(channel,zone,version)

If  you  omit  the  version number, RDIALOG will return the contents of the
FIRST object you've defined with the present zone number.
The Resource Editor
This is a seperate program on the AMOS Accessories disc which allows you to
enter  the various images and messages for your resource banks.  

The  images  are  grabbed  from an IFF format picture.  Once you`ve created
them,  they  can  be loaded into memory and used directly with the internal
LIne,BOx, or VLine commands.  You can also enter your very own messages for
use with the ME function.

See  the  Accessory  section  of  the  AMOS Professional User Guide for
further details.

RESOURCE BANK
{[RAMOSPro_Tutorial:Tutorials/Interface/Simple_requester.AMOS,0,4]Resource Bank}

Tells AMOS where to find the resources used by your Interface programs.

        Resource Bank banknumber

banknumber holds the number of the bank to be allocated for your resources.
If  this  bank  does  not  exist,  you won't get an error, but the editor's
internal resource bank will be used instead.

RESOURCE SCREEN OPEN
{[RAMOSPro_Tutorial:Tutorials/Interface/Simple_requester.AMOS,0,4]Resource Screen Open}

Opens  up  a  screen using the screen settings stored in the resource bank.
These  include the number of colours, the resolution, and the entire colour
palette.

        Resource Screen Open n,w,h,flash

n selects a screen number from 0 to 7 to be defined.

w specifies the width of the screen in pixels.

h enters the height of your screen in lines.

flash tells AMOS whether or not to flash the cursor colour.  If it's set to
zero, the flash will be turned off.  Any other value enters a colour number
to be assigned to the flash effect.

The screen will be automatically installed with the colour palette held in 
the resource bank
RESOURCE UNPACK
Unpacks a single element from the current resource bank, and displays it on
the screen.

        Resource Unpack n,x,y

n holds the number of the element you wish to display.

x,y specify the position of your new image on the screen.
RESOURCE$
Returns one of the messages from the current resource bank, for use by your
AMOS  program.   If  you  haven't  defined  one  of  these banks, you'll be
presented with the standard editor messages from the configuration file.

        m$=Resource$(message)

It can also be used to get vital system information.

Message=0 returns the full pathname of the APSystem folder. 

Message between 0 and -1000 returns Interpretor_Configuration system strings.

        -1  to -9 : default file names
        -10 to -36: all 26 extensions
        -37 to -38: communication ports
        -40:        default cursor flashing

Messages between -1000 and -2000 return Editor_Configuration system strings.

-2001 to -2044: diverse stuff used by the editor!

-2045 to -2049: editor system files
VDIALOG
{[RAMOSPro_Tutorial:Tutorials/Interface/Sliders.AMOS,0,4]=Vdialog}

Reads or modifies the internal variables in any active Interface program 
directly from AMOS Basic.

        Vdialog(channel,var)=value

Assigns a value to an Interface variable.

        value=Vdialog(channel,var)

Reads a value from an Interface variable.

channel sets the number of an open dialogue channel.

var indicates the number of the variable to be accessed.
VDIALOG$
Reads  or  modifies  the  internal string variables in any active Interface
program directly from AMOS Basic.

        Vdialog$(channel,var)=value$

Loads an Interface variable with a string.

        value$=Vdialog$(channel,var)

Reads an Interface string into AMOS Basic.

channel specifies the channel number.

var selects the variable.

System Commands


                             {[IEXEC  ,4,3] Exec             }
                             {[ISYSTEM,4,3] System           }

EXEC
Executes an external program or CLI command.

         Exec "program_name"

As a default, AMOS sends the NIL: device to the instruction. 

         Exec "NEWCLI:"

Opens up a CLI window from your program! 
SYSTEM
Quits the AMOS Professional SYSTEM and returns to the Workbench or CLI.  If
you've  booted  AMOS  Professional from a floppy, you'll now be left with a
completely blank screen!  Time to boot up another program perhaps?

        System

Input/Output

                        {[IHelpKY      ,4,3] The keyboard                 }
                        {[IHelpDiscAcc ,4,3] Disc access                  }
                        {[IHelpPrinter ,4,3] Using the Printer            }
                        {[IHelpSerial  ,4,3] Serial communications        }
                        {[IHelpParallel,4,3] The Parallel port            }

AmigaDos

                        {[IHelpLibs    ,4,3] Libraries                    }
                        {[IHelpDevs    ,4,3] Devices                      }
                        {[IHelparexx   ,4,3] Arexx                        }
                        {[IHelpMT      ,4,3] Multi-tasking                }
                        {[IHelpSysReq  ,4,3] System commands              }

Debugging
                        {[IERR         ,4,3] =Err$                      }
                        {[IERRN        ,4,3] =Errn                      }
                        {[IERROR       ,4,3] Error                      }
                        {[IERRTRAP     ,4,3] =Errtrap                   }
                        {[ION ERROR    ,4,3] On Error                   }
                        {[IRESUME      ,4,3] Resume                     }
                        {[IRESUME LABEL,4,3] Resume Label               }
                        {[IRESUME NEXT ,4,3] Resume Next                }
                        {[ITRAP        ,4,3] Trap                       }

Machine Code
                   {[IAREG    ,4,3] Areg              } {[ILEEK   ,4,3] =Leek             }
                   {[IBIN$   ,4,3] =Bin$             } {[ILOKE    ,4,3] Loke              }
                   {[IBCHG    ,4,3] Bchg              } {[IPEEK   ,4,3] =Peek             }
                   {[IBTST   ,4,3] =Btst             } {[IPEEK$  ,4,3] =Peek$            }
                   {[IBCLR    ,4,3] Bclr              } {[IPLOAD   ,4,3] Pload             }
                   {[IBSET    ,4,3] Bset              } {[IPOKE    ,4,3] Poke              }
                   {[ICALL    ,4,3] Call              } {[IPOKE$   ,4,3] Poke$             }
                   {[ICOPY    ,4,3] Copy              } {[IROL.B   ,4,3] Rol.B             }
                   {[IDEEK   ,4,3] =Deek             } {[IROL.L   ,4,3] Rol.L             }
                   {[IDOKE    ,4,3] Doke              } {[IROL.W   ,4,3] Rol.W             }
                   {[IDREG    ,4,3] Dreg              } {[IROR.B   ,4,3] Ror.B             }
                   {[IFILL    ,4,3] Fill              } {[IROR.L   ,4,3] Ror.L             }
                   {[IHEX$   ,4,3] =Hex$             } {[IROR.W   ,4,3] Ror.W             }
                   {[IHUNT    ,4,3] Hunt              } {[IVARPTR ,4,3] =Varptr           }
AREG
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]=Areg}

AREG is an internal  array of three "pseudo" variables, used to hold copies 
of the 68000 processor chip's first three Address REGisters A0 to A2.

        a=Areg(r)
        Areg(r)=a
BIN$
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]=Bin$}

Converts a decimal number into an appropriate string of BINary digits

These digits are limited to one of the two values "0" and "1"

        =Bin$(number)

Returns the binary number using the fewest possible digits.

        =Bin$(number,n)

Returns the first n digits in the number.
BCHG
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Bchg}

Flips the selected bit in the number from 0 to 1 or vice versa.

        Bchg position,variable

Affects the contents of a single AMOS variable. 

Position holds a value from 0 to 31 which enters the bit number to be changed. 

        Bchg position,expression

If you use an expression rather than a simple variable, BGHG will treat it as
the ADDRESS in memory of a value to be changed.
BCLR
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Bclr}

Replaces the chosen binary bit with a value of zero.

        Bclr position,variable

Changes the bit in a normal AMOS variable.

        Bclr position,expression

Zeros the bit at the ADDRESS given by the expression.
BSET
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Bset}

Sets an individual binary bit in your number to 1.

        Bset position,variable

Affects the contents of a variable.

        Bset position,expression

Sets the bit at an ADDRESS in memory.
BTST
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]=Btst}

Tests a single bit in your number and returns a value of -1 (true) if it's a
one, or 0 (False) if it's a zero.

        test=Btst(position,variable)

Checks a bit in your selected variable. position holds a bit number ranging
from 0 to 31.

        test=Btst(position,expression)

Evaluates the expression, and tests the bit at the resulting memory ADDRESS.
The bit position is restricted to values from 0 to 7.
CALL
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]Call}

Executes a 68000 machine code program from either an address in memory,or a
memory  bank.  This program should have been previously installed using the
PLOAD instruction from AMOS Basic.

        Call address
        Call bank number

You  can  also  include  paramters  in  this  instruction.   These  will be
automatically pushed onto the A3 stack at the start of your routine.

        Call address,parameter list
        Call bank number,parameter list
COPY
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]Copy}

COPY is used to move large chunks of Amiga memory from one location to 
another.

        Copy start, finish To destination
DEEK
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]=Deek}

Reads a two-byte word from an EVEN memory address.

        Print Deek(address)
DOKE
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]Doke}

Loads a two-byte number into an EVEN memory address.

        Doke address,value
DREG
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]=Dreg}

DREG is a variable used to pass information to and from the Amiga's 68000 data
registers. (D0 to D7)

        d=Dreg(r)
        Dreg(r)=d
FILL
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]Fill}

Fills a selected area of memory with a four-byte FILL pattern.

All addresses MUST BE EVEN! 

        Fill start To finish, pattern

HEX$
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]=Hex$}

Translates a number into a list of HEXadecimal digits. 

These digits can take any of sixteen values from "0" to "9" and "A" through 
"F".

        =Hex$(number)

Returns the Hexadecimal number using the fewest possible digits.

        =Hex$(number,n)

Returns the first n digits in the number.
HUNT
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]=Hunt}

Hunts for a series of ASCII characters in the Amiga's memory. 

        first=Hunt(start To finish,s$)

After the search is complete test will be loaded with the first occurrence 
of the string s$ in memory.
LEEK
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]=Leek}

Reads a four-byte word stored at the even numbered memory address.

        Print Leek(address)
LOKE
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]Loke}

Copies a four-byte number into an even address in memory.

        Loke address,number

PEEK
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]=Peek}

Returns the contents of an 8-bit byte at the specified memory address.

        B=Peek(address)
PEEK$

PEEK$ reads length characters from your address and returns it as a normal 
AMOS string. 

        s$=PEEK$(address, length)
        S$=PEEK$(address, length,stop$)

address is the location of the first character to be read.

length holds the maximum number of characters to copy into the new string. 
If it's not a sensible value, the length will be assumed to be 65500.

stop$ sets an optional break character. If it's included, AMOS will stop 
reading the moment it encounters a stop$ character in your memory area.
PLOAD
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]Pload}

Reserves a memory bank and LOADs it with machine code from the disc.

        Pload "filename",banknumber

If banknumber is negative, it will be multiplied by -1 to calculate the number
of an AMOS memory bank. Your program will now be installed in CHIP RAM if it's
available. 
POKE
{[RAMOSPro_Examples:Examples/H-5/Help_57.AMOS,0,4]Poke}

Shoves a byte number in the range from 0 to 255 into the your chosen memory
address.

        Poke address,number
POKE$

Takes a source string and copies it directly to your chosen memory locations,
a character at a time.

POKE$ address, string$

address holds the address of the first byte to be loaded with your new string
data. The copying operation will continue until AMOS reaches the last 
character in your source string. Therefore, the end address will be:

address+Len(string$)-1
ROL.B
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Rol.B}

Rotates the first eight binary bits in a number a specific number of places 
to the left.

        Rol.B places,variable
        Rol.B places,expression

Note: If you enter an expression in this instruction, it will be treated as 
an ADDRESS.
ROL.L
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Rol.L}

Rotates all 32 bits in your number to the left.

        Rol.L places,variable
        Rol.L places,expression

variable is a normal AMOS variable you wish to rotate.

An expression is evaluated by AMOS Basic, and used as address of some data
you wish to change.
ROL.W
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Rol.W}

Rotates the first sixteen bits in your variable or memory location to the 
left.
        Rol.W places,variable
        Rol.W places,expression

If you use an expression rather than a variable, it will be treated as 
an address. 
ROR.B
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Ror.B}

Rotates the first binary bits in a number a specific number of places to the
right.

        Ror.B places,variable
        Ror.B places,expression

Note: If you enter an expression in this instruction, it will be treated as 
an ADDRESS. 
ROL.L
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Ror.L}

Rotates all the bits in your number to the right.

        Ror.L places,variable
        Ror.L places,expression

variable is a normal AMOS variable you wish to rotate.

An expression is evaluated by AMOS Basic, and used as address of some data 
you wish to change.
ROR.W
{[RAMOSPro_Examples:Examples/H-5/Help_55.AMOS,0,4]Ror.W}

Rotates the first sixteen bits in your variable or memory location to the
right.

        Rol.W places,variable
        Rol.W places,expression

If you use an expression rather than a variable, it will be treated as an 
address instead.
VARPTR
{[RAMOSPro_Examples:Examples/H-5/Help_56.AMOS,0,4]=Varptr}

Returns the address of an AMOS Basic VARiable in memory. Warning! 

The address of string variable can change dramaticaly during the course of 
your programs. So only POKE values into an address you KNOW to be correct!

        address=Varptr(variable)

See the AMOSPro User Guide for a complete explanation of this feature.

Tables

                        {[IHelpAscTab  ,4,3] Ascii table                  }
                        {[IHelpScantab ,4,3] Useful scancodes             }
Miscellaneous commands
                        {[IADD     ,4,3] Add                            }
                        {[IAND     ,4,3] And                            }
                        {[IDATA    ,4,3] Data                           }
                        {[IDEC     ,4,3] Dec                            }
                        {[IFALSE  ,4,3] =False                         }
                        {[IINC     ,4,3] Inc                            }
                        {[INOT     ,4,3] Not                            }
                        {[IOR      ,4,3] Or                             }
                        {[IREAD    ,4,3] Read                           }
                        {[IRESTORE ,4,3] Restore                        }
                        {[ITIMER   ,4,3] Timer                          }
                        {[ITRUE   ,4,3] =True                          }
                        {[IWAIT    ,4,3] Wait                           }
                        {[IMOD     ,4,3] =Mod                           }
ADD
{[RAMOSPro_Examples:Examples/H-0/Help_1.amos,0,4]Add}

Adds a number or expression to an integer variable at maximum speed.

        Add variable,expression

There's also a second, more powerful version of the command as well.

        Add variable,expression,min To max

Adds your expression to the variable as before. But after the result reaches
one of the limits, the variable cycles back from the start.

AND
Performs a logical AND operation between your two numbers.  It's often used
as part of a test to check for a number of different eventualities.

        Print A and B
        If T=2 and V=3 Then Print "TV"
DATA
{[RAMOSPro_Examples:Examples/H-4/Help_48.AMOS,0,4]Data}

Enters  a  list  of DATA items into an AMOS Professional program, which can
then be loaded into one or more variables using the READ instruction.  Each
item must be separated by a comma.

        Data 1,2,3,"AMOS Professional"
DEC
{[RAMOSPro_Examples:Examples/H-0/Help_1.amos,0,4]Dec}

Quickly subtracts one from your selected integer variable.

        Dec variable
FALSE
{[RAMOSPro_Examples:Examples/H-5/Help_53.AMOS,0,4]=False}

Returns  a  value  of  zero.   This value is used by tests to represent the
failure of a condition.

        If False Then Print "This will NEVER be printed!"
        Print False
INC
{[RAMOSPro_Examples:Examples/H-0/Help_1.amos,0,4]Inc}

Quickly adds a value of one to an integer variable.

        Inc variable
MOD
MOD  is  a  useful  little  function  which  allows you to cycle a variable
through a repetitive series of values.  It works by returning the remainder
after a division.

        r=v Mod d

This is equivalent to:

        R=v - Int(v/d)*d
NOT
{[RAMOSPro_Examples:Examples/H-5/Help_53.AMOS,0,4]Not}

Switches  every  binary  digit  in  your  number to a different state.  It's
commonly  used as part of a IF..THEN statement to reverse the effect of the
tests.

       Print Bin$(Not %1010,4)
       If Not (A=1 and B=2) Then Print "Successful"
OR
Combines two binary bit patterns together.  OR is generally used as part of
a test, to check a number of exclusive possibilities.

      Print 1 or 2
      If A=2 or B=3 Then Print A*B
READ
{[RAMOSPro_Examples:Examples/H-4/Help_48.AMOS,0,4]Read}

READs  information  from a DATA statement into a list of variables, using a
special  marker to locate the next item of data to be read.  Variables must
be  the  same  type as the data already held at the current position in the
program, and should be separated by commas.

        Read list of variables

RESTORE
{[RAMOSPro_Examples:Examples/H-4/Help_48.AMOS,0,4]Restore}

Changes the position of the starting point used by the next READ operation.

        Restore label
        Restore number
TIMER
{[RAMOSPro_Examples:Examples/H-5/Help_53.AMOS,0,4]=Timer}

is a reserved variable that counts off TIME in units of one 50th of a second.


        t=Timer
TRUE
{[RAMOSPro_Examples:Examples/H-5/Help_53.AMOS,0,4]=True}

Returns  a value of -1.  This is generated by tests such as (A=3) or (B<>4)
and denotes a successful check.

         If -1 Then Print "Minus 1 is True"
         If True Then Print "and True is";True
WAIT
{[RAMOSPro_Examples:Examples/H-5/Help_53.amos,0,4]Wait}

Pauses  an  AMOS  Professional  program and makes it WAIT for the number of
50ths of a second you specify.

       Wait delay
Screen Zones

                        {[IHZONE      ,4,3] =Hzone                      }
                        {[IMOUSE ZONE ,4,3] =Mouse Zone                 }
                        {[IRESERVE ZONE,4,3] Reserve Zone                }
                        {[IRESET ZONE  ,4,3] Reset Zone                  }
                        {[ISET ZONE    ,4,3] Set Zone                    }
                        {[IZONE       ,4,3] =Zone                       }

HZONE
{[RAMOSPro_Examples:Examples/H-2/Help_23.AMOS,0,4]=Hzone}

Finds the screen zone at the requested HARDWARE coordinates.

         zone_number=Hzone(hx,hy)

MOUSE ZONE
{[RAMOSPro_Examples:Examples/H-2/Help_23.AMOS,0,4]=Mouse Zone}

Finds the screen ZONE under MOUSE pointer.

        zone_number=Mouse Zone
RESERVE ZONE
{[RAMOSPro_Examples:Examples/H-2/Help_21.AMOS,0,4]Reserve Zone}

RESERVEs enough memory for a selected number of detection ZONEs.  This must
be  set  up  before you define your zones using SET ZONE.  If you leave out
the number of zones, all current zone definitions will be wiped out.

        Reserve Zone zone_number
        Reserve Zone
RESET ZONE
{[RAMOSPro_Examples:Examples/H-2/Help_23.AMOS,0,4]Reset Zone}

Erases one or more screen ZONEs from the display.

        Reset Zone

Kills all currently defined zones. Dead!

        Reset Zone zone_number

Only resets a single zone.
SET ZONE
{[RAMOSPro_Examples:Examples/H-2/Help_21.AMOS,0,4]Set Zone}

SETs up a rectangular screen ZONE for testing with the ZONE functions.

        Set Zone number,tx,ty To bx,by

tx,ty hold the coordinates of the top left corner of your zone.

bx,by enter the point diagonally opposite.
ZONE
{[RAMOSPro_Examples:Examples/H-2/Help_23.AMOS,0,4]=Zone}

Returns  the  number  of  the  current  screen ZONE at the selected graphic
coordinates.

        Zone number=Zone(x,y)

You can also include a screen number with this function as well.

        zone number=Zone(screennumber,x,y)
Text
             {[IAT        ,4,3] =At        } {[ICLINE      ,4,3] Cline      } {[IPAPER      ,4,3] Paper      } {[ITAB$      ,4,3] =Tab$      }
             {[IBORDER$   ,4,3] =Border$   } {[IFONTDAT    ,4,3] Font Editor} {[IPAPER$    ,4,3] =Paper$    } {[IUNDER ON   ,4,3] Under On   }
             {[ICDOWN$    ,4,3] =Cdown$    } {[ICMOVE      ,4,3] Cmove      } {[IPEN        ,4,3] Pen        } {[IUNDER OFF  ,4,3] Under Off  }
             {[ICUP$      ,4,3] =Cup$      } {[IHOME       ,4,3] Home       } {[IPEN$      ,4,3] =Pen$      } {[IUSING      ,4,3] Using      }
             {[ICLEFT$    ,4,3] =Cleft$    } {[ICMOVE$     ,4,3] Cmove$     } {[IPRINT      ,4,3] Print      } {[IWRITING    ,4,3] Writing    }
             {[ICUP       ,4,3] Cup        } {[IINVERSE ON ,4,3] Inverse On } {[IREMEMBER X ,4,3] Remember X } {[IX GRAPHIC  ,4,3] =X Graphic }
             {[ICDOWN     ,4,3] Cdown      } {[ICRIGHT     ,4,3] Cright     } {[IREMEMBER Y ,4,3] Remember Y } {[IX CURS    ,4,3] =X Curs    }
             {[ICENTRE    ,4,3] Centre     } {[IINVERSE OFF,4,3] Inverse Off} {[IREPEAT$   ,4,3] =Repeat$   } {[IX TEXT    ,4,3] =X Text    }
             {[ICURS OFF  ,4,3] Curs Off   } {[ICRIGHT$    ,4,3] =Cright$   } {[ISET CURS   ,4,3] Set Curs   } {[IY TEXT    ,4,3] =Y Text    }
             {[ICURS ON   ,4,3] Curs On    } {[ILOCATE     ,4,3] Locate     } {[ISET TAB    ,4,3] Set Tab    } {[IY CURS    ,4,3] =Y Curs    }
             {[ICLEFT     ,4,3] Cleft      } {[IMEMORIZE Y ,4,3] Memorize Y } {[ISHADE ON   ,4,3] Shade On   } {[IYGRAPHIC  ,4,3] =Y Graphic }
             {[ICURS PEN  ,4,3] Curs Pen   } {[IMEMORIZE X ,4,3] Memorize X } {[ISHADE OFF  ,4,3] Shade Off  } {[IZONE$     ,4,3] =Zone$     }

AT
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=At}

Adds  special  control  codes  to a string which allow you to move the text
cursor directly as the string is printed.

        T$=At(x,y)+"Moved Text"
BORDER$
{[RAMOSPro_Examples:Examples/H-2/Help_21.AMOS,0,4]=Border$}

Displays a border around your text when it's printed on the screen.


        b$=Border$("string",n)

n  can  range  between  1  and  16,  but  only  the first three borders are
currently defined.

Note  that Border$ needs room for an extra character for the border.  So it
should only be used if the X coordinate is larger than 0.

CDOWN
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]Cdown}

Moves the text cursor one place down.

        Cdown
CDOWN$
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Cdown$}

Returns  a  control  string  which moves the cursor one character downwards
when it is printed.

        Print Cdown$

CDOWN$ is also returned when you press the DOWN ARROW key from the keyboard.
CENTRE
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]Centre}

Centres your text neatly on the current cursor line.

        Centre "text"

        Centre "this is in the centre"
CLEFT
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Cleft}

Moves the text cursor one place to the left.

        Cleft
CLEFT$
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Cleft$}

Returns  a  control string which moves the cursor one character to the left
when it is printed.

        Print Cleft$

CLEFT$ is also returned when you press the LEFT ARROW key from the keyboard.
CLINE
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]Cline}

Clears the entire line starting from the current cursor position.

        Cline

        Cline n

Erases the first n characters in the line.
CMOVE
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]Cmove}

Moves the text cursor to a new location, relative to the current position. 

        Cmove unitsright,unitsdown

Providing you leave in the comma, either of the distances can be omitted.
CMOVE$
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=Cmove$}

Generates  some  codes  which move the text cursor relative to its present
position.

        Print Cmove$(unitsright,unitsdown)
CRIGHT
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]Cright}

Moves the text cursor one place to the right.

        Cright
CRIGHT$
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Cright$}

Returns  a control string which moves the cursor one character to the right
when it is printed.

        Print Cright$

CRIGHT$ is also returned when you press the RIGHT ARROW key.
CUP
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]Cup}

Moves the text cursor one place up.

        Cup
CUP$
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Cup$}

Returns  a  control  string  which moves the cursor one place up when it is
printed.

        Print Cup$

CUP$ is also returned when you press the UP ARROW key.
CURS OFF
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Curs Off}

Disables the flashing text CURSor of the current screen

        Curs Off
CURS ON
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Curs On}

Automatically displays a flashing bar at the current cursor position.

        Curs On
CURS PEN
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]Curs Pen}

Changes  the  colour  of  the  text cursor when it's visible on the screen.
It's usually colour three.

        Curs Pen index
Font Editor
{[RAMOSPro_Accessories:Font8x8_Editor.AMOS] Font Editor}

The  AMOSPro  font editor allows you to generate your own 8x8 fonts for all
your  text operations.  You can also access any of the standard Amiga fonts
with the alternative `Graphic Text` commands.

HOME
{[RAMOSPro_Examples:Examples/H-1/Help_18.AMOS,0,4]=Home}

Moves  your  text  cursor  HOME  to the top-left-hand corner of the current
screen:  in other words to TEXT coordinates 0,0.

        Home
INVERSE ON
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Inverse On}

Swaps text and background colours for all future text operations.

        Inverse On
INVERSE OFF
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Inverse Off}

Deactivates inverse mode.

        Inverse Off
LOCATE
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]Locate}

Moves the text cursor to the new LOCATion on the screen.  As you are moving
a  text  cursor,  you  should  enter  the location in character coordinates
rather than pixel coordinates.

        Locate x,y
MEMORIZE X
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Memorize X}

Saves the X coordinate of the text cursor.

        Memorize X

The coordinate can be recalled using REMEMBER X
MEMORIZE Y
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Memorize Y}

Stores the Y coordinate of the text cursor in memory.

        Memorize Y
PAPER
{[RAMOSPro_Examples:Examples/H-1/Help_15.AMOS,0,4]Paper}

Sets the colour to be used as the background PAPER for your text PEN.

        Paper colournumber
PAPER$
{[RAMOSPro_Examples:Examples/H-1/Help_15.AMOS,0,4]=Paper$}

Returns  an  internal  code  which  changes  the paper colour whenever it's
printed on the screen.

        T$=Paper$(colournumber)
PEN
{[RAMOSPro_Examples:Examples/H-1/Help_15.AMOS,0,4]Pen}

Sets the colour of the PEN to be used for writing text in the current screen. The colour can be selected from one of 64 alternative colours, depending on your current graphics mode.

        Pen colournumber
PEN$
{[RAMOSPro_Examples:Examples/H-1/Help_15.AMOS,0,4]=Pen$}

Returns a control code which changes the pen colour inside a piece of text.

        T$=PEN$(colour)
PRINT
{[RAMOSPro_Examples:Examples/H-5/Help_52.AMOS,0,4]Print}

PRINTs  items  on screen, made up from any groups of variables or constants
separated  by semi-colons or commas.  As a short-cut, the [?] character key
can be used instead.

        Print variable list
        ? variable list
REMEMBER X
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Remember X}

Moves the text cursor to the position you've previously saved with
MEMORIZE X.

        Remember X
REMEMBER Y
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Remember Y}

Restores  the  cursor  to  the  Y  coordinated you've previously saved with
MEMORIZE Y.

        Remember Y
REPEAT$
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]=Repeat$}

Repeats  the  string  of  characters  in  S$ n times on the screen.  Only a
single copy of S$ is kept in memory.

        c$=REPEAT$(s$,n)
SET CURS
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]Set Curs}

Alters the shape of the CURSor by changing the bit-patterns L1 to L8.

        Set Curs L1,L2,L3,L4,L5,L6,L7,L8
SET TAB
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]Set Tab}

Sets the distance to be moved when a TAB character is printed.

        Set Tab n
SHADE ON
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Shade On}

Starts up an attractive shading effect for all future text.

        Shade On

SHADE OFF
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Shade Off}

Deactivates shading effect.

        Shade Off
TAB$
{[RAMOSPro_Examples:Examples/H-2/Help_20.AMOS,0,4]=Tab$}

Returns  a  TAB character.  This will move the cursor several places to the
right when it's printed on the screen.  See SET TAB

        Print Tab$;"test"
USING
{[RAMOSPro_Examples:Examples/H-5/Help_52.AMOS,0,4]Using}

USING  is  called  after a PRINT statement for making subtle changes to the
way output is printed from a variable list.  Special characters can be used
in the format$ string, each one having a different effect.

        Print Using format$;variable list.

The format string can contain the following symbols:

# print a single digit from your number.  Unused digits will be replaced by
  spaces.

+ adds a + or - sign to the number as appropriate.

- displays a minus sign if the number is negative.

. inserts a decimal point on the number and centres it.

; centres the number but doesn`t output a decimal point.

^ prints the number in scientific, or exponential format.
WRITING
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Writing}

Sets the writing mode for all future text operations.

        Writing w1[,w2]

The first value selects the actual writing style.

=1 REPLACE (default)
=2 OR
=3 XOR
=4 AND
=5 IGNORE (don't do any printing at all!)

The  second  value  allows  you  to choose which parts of your text will be
printed on the screen.

=0  Normal. Both Ink and Paper will be printed
=1  Paper.  Only print the background
=2  Pen     Writes the text on a background of colour zero. 
            Useful with OR mode.
X CURS
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]=X Curs}

Returns the X coordinate of your text CURSor, in text format.

        x=Xcurs
X GRAPHIC
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=X Graphic}

Converts a X coordinate in TEXT format into a normal screen coordinate.

        tx=X Graphic(x)
X TEXT
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=X Text}

Converts an X coordinate from graphic format into a TEXT format coordinate,
relative  to  the  current  screen.  If the screen coordinate is outside of
this screen then a negative result will be given.

        t=X Text(xcoordinate)
YCURS
{[RAMOSPro_Examples:Examples/H-1/Help_19.AMOS,0,4]=Y Curs}

Returns Y coordinate is of your text CURSor, in text format.

        y=Ycurs
Y GRAPHIC
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=Y Graphic}

Converts a Y coordinate from text format to screen format.

        Y Graphic(ty)
Y TEXT
{[RAMOSPro_Examples:Examples/H-1/Help_17.AMOS,0,4]=Y Text}

Converts  a Y coordinate from graphic format into a TEXT format coordinate,
relative  to  the  current  screen.  If the screen coordinate is outside of
this screen then a negative result will be given.

        t=Y Text(ycoordinate)

UNDER ON
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Under On}

Underlines all future text.

        Under On

Starts underline mode
UNDER OFF
{[RAMOSPro_Examples:Examples/H-1/Help_16.AMOS,0,4]Under Off}

Turns off underline mode.

        Under Off
ZONE$
{[RAMOSPro_Examples:Examples/H-2/Help_21.AMOS,0,4]=Zone$}

Defines  a  screen  zone around your text.  This can be used in conjunction
with the MOUSE ZONE function to create simple buttons.

        t$=Zone$(button$,z)

Where z is the number of your new zone.
Disc Access

                {[IAPPEND      ,4,3] Append        } {[IDIR/W       ,4,3] Dir/w         } {[ILOF        ,4,3] =Lof          }
                {[IASSIGN      ,4,3] Assign        } {[IEOF        ,4,3] =Eof          } {[IMKDIR       ,4,3] Mkdir         }
                {[ICLOSE       ,4,3] Close         } {[IEXIST      ,4,3] =Exist        } {[IOPEN IN     ,4,3] Open In       }
                {[IDEV FIRST$ ,4,3] =Dev First$   } {[IFIELD       ,4,3] Field         } {[IOPEN OUT    ,4,3] Open Out      }
                {[IDEV NEXT$  ,4,3] =Dev Next$    } {[IFSEL$      ,4,3] =Fsel$        } {[IOPEN RANDOM ,4,3] Open Random   }
                {[IDFREE      ,4,3] =Dfree        } {[IGET         ,4,3] Get           } {[IPARENT      ,4,3] Parent        }
                {[IDIR$       ,4,3] =Dir$         } {[IINPUT#      ,4,3] Input#        } {[IPOF        ,4,3] =Pof          }
                {[IDIR FIRST$ ,4,3] =Dir First$   } {[IINPUT$     ,4,3] =Input$       } {[IPRINT#      ,4,3] Print#        }
                {[IDIR NEXT$  ,4,3] =Dir Next$    } {[IKILL        ,4,3] Kill          } {[IPUT         ,4,3] Put           }
                {[IDISC INFO$ ,4,3] =Disc Info$   } {[ILDIR        ,4,3] Ldir          } {[IRENAME      ,4,3] Rename        }
                {[IDRIVE      ,4,3] =Drive        } {[ILDIR/W      ,4,3] Ldir/w        } {[ISET DIR     ,4,3] Set Dir       }
                {[IDIR         ,4,3] Dir           } {[ILINE INPUT# ,4,3] Line Input#   } {[ISET INPUT   ,4,3] Set Input     }

APPEND
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]Append}

Adds information to the end of an existing sequential file, allowing you to
expand your file after it has been defined.

        Append channelnumber,name$
ASSIGN
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]Assign}

Assigns  a general name to a folder or device just like the normal AmigaDos
ASSIGN instruction.

Assign "Disc_Name:" To "Path:Name/"

"Disc_Name:"

Holds  a  string  with  the  name  of  the  assigned  disc  to create.  The
semi-colon is mandatory and no spaces are allowed.

"Path:Name/" 

This must be a valid pathname to either a directory or a file.
CLOSE
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]Close}

CLOSEs one or more files on the disc.

        Close

Closes ALL the current files.

        Close filenumber

Closes a single file.
DEV FIRST$
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]=Dev First$}

Returns  a  string containing the name of the FIRST DEVice from the current
device list.

        dev$=Dev First$("filter")
DEV NEXT$
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]=Dev Next$}

Returns  the  NEXT DEVice name that satisfies the filter used by a previous
DEV  FIRST$ call.  If the end of the device list is reached, a blank string
will be returned.

        dev$=Dev Next$
DFREE
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]=Dfree}

Reveals the amount of free Disc space on the current device,in bytes.

        Print Dfree
DIR
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]Dir}

Prints out the DIRectory of files held on your current disc.

Here are some typical uses.

        Dir "Df0:" : Rem List all files in internal drive
        Dir "Examples:" : Rem List all files on named disc
        Dir "A*" : Rem List all files starting with A
        Dir "*.*" : Rem List all files with an extension
DIR/W
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]Dir/W}

Displays the DIRectory of your current disc in twin columns.

        Dir/w "Df0:"
DIR FIRST$
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]=Dir First$}

Returns  a  string  containing the name and the length of the FIRST file in
the disc DIRectory.

        Print Dir First$("*.*")
DIR NEXT$
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]=Dir Next$}

Returns  the NEXT filename in the DIRectory listing created by a DIR FIRST$
command.

        F$=Dir Next$
DIR$
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]=Dir$}

Enters  or reads the name of the directory to be used as the starting point
for subsequent disc operations.

        s$=DIR$
        DIR$=s$
DISC INFO$
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]=Disc Info$}

Returns  a  string containing INFOrmation on a named file or directory in a
disc.   The  information  is  returned  in the form of the name of the disc
followed by the available free space.

        a$=Disc Info$("name")
DRIVE
Checks for the existence of a specific drive.

        test=Drive("drive")

If  the drive is connected to your Amiga,m you'll get a value of -1 (True),
otherwise the result will be 0 (False)

        Print Drive("Dh0")
EOF
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Eof}

Tests  to  see  if the End Of a File has been reached, returning -1 for yes
and 0 for a no.

        flag=Eof(channel)
EXIST
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]=Exist}

Checks  to  see  if  a specific file or directory actually exists.  If it's
available,  you'll  get  a value of True (-1).  Otherwise you'll get a zero
instead.

        test=Exist("pathname")
        test=Exist("filename")
FIELD
{[RAMOSPro_Examples:Examples/H-7/Help_71.AMOS,0,4]Field}

Defines a record up to 65535 bytes long, for a random-access file.

       Field channel, length As field$

FSEL$
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]=Fsel$}

Opens  an  AMOS  Professional  File  SELector allowing you to choose a file
directly from disc, starting from the search pattern in path$.

        f$=Fsel$(path$)

You  may  also enter a default filename with default$, and include optional
title strings.

        f$=Fsel$(path$,title1$,title2$)

        f$=Fsel$(path$,default$,title1$,title2$)
GET
{[RAMOSPro_Examples:Examples/H-7/Help_71.AMOS,0,4]Get}

Fetches  a  record  stored  in an OPENed random access file, and loads this
into a set of string variables you`ve selected with the FIELD command.

        Get channel,record_number
INPUT#
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]Input#}

Reads information from a file or a device and loads it into your variables.

        Input# channel,variable list
INPUT$
There are two different forms of this command.  The simplest reads a number
of characters straight from the keyboard.

        x$=Input$(character count)

{[RAMOSPro_Examples:Examples/H-4/Help_42.AMOS,0,4]=Input$}(characters)

You can also enter your characters directly from an open file or a device.

        x$=Input$(channel,character count)

{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Input$}(channel,characters)

KILL
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]Kill}

Permanently deletes a selected file from the disc.

       Kill filename
LDIR
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]Ldir}

Lists out the DIRectory of your files onto the printer, if it's available.

          Ldir "pathname"
LDIR/W
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]Ldir/W}

Lists  the  DIRectory  of  your disc onto the printer, using a compact, two
column format.

          Ldir/w "Df0:"
LINE INPUT#
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]Line Input#}

INPUTs  a  list  of  variables  one  at  a  time  from the device opened to
#channel,  separated  by  your  selected  character,  instead of the normal
comma.

        Line Input #channel,separator$,variable list
LOF
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Lof}

Returns the Length of an Open File.

        length=Lof(channel)
MKDIR
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]Mkdir}

Creates  a  new  directory or folder on the disc, starting from the current
path.

      Mkdir folder$
OPEN IN
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]Open In}

OPENs a sequential file for INput.

        Open In channelnumber,filename$

Available channels range from 1 to 10.
OPEN OUT
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]Open Out}

OPENs a file for OUTput, identified via channels 1 to 10.

        Open Out channelnumber,filename$
OPEN RANDOM
{[RAMOSPro_Examples:Examples/H-7/Help_71.AMOS,0,4]Open Random}

OPENs  a RANDOM access file on the current disc.  Before using one of these
files, you should set up the record structure with the FIELD command.

        Open Random channelnumber,filename$
PARENT
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]Parent}

Moves the current search path to the parent of the present directory.
POF
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Pof}

Changes the reading or writing POsition of a File.

        Pof(channelnumber)=position
PRINT#
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Print#}

PRINTs a list of variables to a file or to a device.

        Print #channel,variable list
PUT
{[RAMOSPro_Examples:Examples/H-7/Help_71.AMOS,0,4]Put}

Takes  a  record from memory and PUTs it into a selected record number of a
random access file.

        Put channelnumber,recordnumber
RENAME
{[RAMOSPro_Examples:Examples/H-4/Help_45.AMOS,0,4]Rename}

Renames your selected file on the disc.

        Rename old$ to new$
SET DIR
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]Set Dir}

Controls  the  style  of  the  DIRectory  listing, by setting the number of
characters to be displayed from 1 to 100, followed by optional pathnames to
be filtered out of directory searches.

        Set Dir number,filter$
SET INPUT
{[RAMOSPro_Examples:Examples/H-6/Help_69.AMOS,0,4]=Set Input}

SETs  the  characters  you  want  to  INPUT  to  end  a line of data.  Many
computers need both a [Return] and [line feed] character at the end of each
line,  but  the  Amiga  only  needs a [line feed].  Make the second value a
negative number if you only want to use a single character.

        Set Input 10,-1 : Rem Standard Amiga format
        Set Input 13,10 : Rem PC or ST compatible format

The Bare Bones
                        {[IDEFFN       ,4,3] Def Fn                       }
                        {[IDIM         ,4,3] Dim                          }
                        {[IEND         ,4,3] End                          }
                        {[IEDIT        ,4,3] Edit                         }
                        {[IDIRECT      ,4,3] Direct                       }
                        {[IFREE        ,4,3] =Free                        }
                        {[IMONITOR     ,4,3] Monitor                      }
                        {[IREM         ,4,3] Rem                          }
                        {[IREADTEXT    ,4,3] Read Text$                   }
                        {[ISET BUFFER  ,4,3] Set Buffer                   }
DEF FN
{[RAMOSPro_Examples:Examples/H-6/Help_61.amos,0,4]Def Fn}

Creates  a user-DEFined FunctioN, used for the quick calculation of values.
It  must  be  given  a  name,  followed  by  a  bracketed list of variables
separated  by  commas.   The  expression  can  include  any AMOS functions,
limited to a single line of your program.  (See FN).

        Def Fn name(variables)=expression
DIM
{[RAMOSPro_Tutorial:Tutorials/Arrays.AMOS,0,4]Dim}

DIMensions  an  array  by  defining a table of variables.  The array's size
(DIMension) is set by values inside brackets.

        Dim variable(x,y,z)
        Dim variable#(x)
        Dim Variable$(x,y)
DIRECT
{[RAMOSPro_Examples:Examples/H-1/Help_12.AMOS,0,4]Direct}

Terminates your AMOS program and jumps straight to direct mode.

       Direct
EDIT
{[RAMOSPro_Examples:Examples/H-1/Help_11.AMOS,0,4]Edit}

Stops your current program and returns immediately to the editor screen.

      Edit

FN
{[RAMOSPro_Examples:Examples/H-6/Help_61.amos,0,4]=Fn}

Calls up and executes the user-defined FuNction by its name, followed by an
optional variable list.  (See Def Fn).

        Def Fn name (variable list)=expression
        Print Fn name (variable list)

MONITOR
Calls  up  the  AMOS  Professional  monitor  at  the  current point in your
program.   You  can  now  debug you program a line at a time using the many
powerful testing facilities provided by the monitor.

        Monitor


See  section  12.01.01  from  the user guide for an detailed explanation of
this system.

{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Worked Example}

READ TEXT
{[RAMOSPro_Examples:Examples/H-8/Help_82.AMOS,0,4]Read Text$}

Displays some text from either a file, or a memory bank using an attractive,
on-screen text reader.

        Read Text filename$

Loads the file into memory, and displays it on the screen in ASCII format.

        Read Text title$ ,address,length

address: is the address of the first line of your text.

length: the length of the text in characters.

SET BUFFER
{[RAMOSPro_Examples:Examples/H-6/Help_64.amos,0,4]Set Buffer}

SETs the size of the BUFFER area that holds your variables in units of a 
kilobyte. (1024 bytes)

        Set Buffer kilobytes

Program run commands

                         {[IBREAK ON     ,4,3] Break On                  }
                         {[IBREAK OFF    ,4,3] Break Off                 }
                         {[ICOMMAND LINE$,4,3] Command Line$             }
                         {[IINCLUDE      ,4,3] Include                   }
                         {[ION BREAK     ,4,3] On Break                  }
                         {[IPRUN         ,4,3] Prun                      }
                         {[IPRG STATE   ,4,3] =Prg State                }
                         {[IPRG UNDER   ,4,3] =Prg Under                }
                         {[IRUN          ,4,3] Run                       }
                         {[ISTOP         ,4,3] Stop                      }

BREAK ON
{[RAMOSPro_Examples:Examples/H-1/Help_14.AMOS,0,4]Break On}

Turns ON the program-interrupt BREAK routine normally activated by pressing
the [Control]+[C] keys.

        Break On 
        Break Off
BREAK OFF
{[RAMOSPro_Examples:Examples/H-1/Help_14.AMOS,0,4]Break On}

Stops  anyone  from  interrupting  your  program  while it is running using
Control+C.   Only  use  this  in the FINAL versions of your programs!  Once
it's activated, YOU CAN'T RETURN TO THE AMOS EDITOR until the program exits
naturally.

COMMAND LINE$

is  a  reserved variable used to transfer parameter strings between several
AMOS  programs.   It's often used in conjunction with the RUN file$ command
to  chain  several  programs  together.   Alternatively, if your program is
called  as  an Editor Accessory, COMMAND LINE$ will be loaded with the AMOS
instruction underneath the Edit cursor.

        Command Line$="information"
INCLUDE

Loads and merges an entire AMOS program from the disc whenever your current
listing  is  executed.   This  include file can contain anything you like,
from procedure  definitions, to commonly used initialisation code.  But it
can't contain it's own INCLUDE statements.

        Include "File_To_Include.AMOS"

Your  filename  should be a constant rather than a string variable, as AMOS
merges  the  include  file  during the TESTING process.  
ON BREAK
Intercepts  the  Control-C  command  and  calls  your selected AMOS routine
whenever the user attempts to leave your program.

        On Break Goto label
        On Break Gosub label

        {[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]On Break Proc name}
PRG STATE
This  handy  function  lets  you  know  how  your program was launched.  It
returns one of three possible values:

  0 : if your program was run under the AMOS interpreter.
  1 : if your program was run under the AMOS run-only module.
 -1 : if your program is compiled.
PRUN

PRUN  is a mix between calling a procedure and RUNning another program:  it
loads  and  (if  necessary),  RUNs  your  new  program, and returns to your
original calling program when it's finished.

        Prun "Program_name"

It's a sort of Gosub Program command!
PRG UNDER
Checks if an AMOS program is accessible "under" the current one.

        test=Prg Under

test=0 (false)

The current listing has been run directly from the Editor, as a normal AMOS
program.

test=1

Your   program   is   the   only   one  being  executed,  BUT  is  not  the
currently-edited  program.   This happens when you "run hidden program", or
use "program to menu".

test=-1 (true)

The program was PRUNned from another program.
RUN
{[RAMOSPro_Examples:Examples/H-4/Help_44.AMOS,0,4]Run}

RUNs an AMOS Professional program.

        Run file$

Loads and Runs  the  program  'file$'. Use  COMMAND  LINE$  to  pass
information between programs.

Note: Run will not work from Direct Mode.

STOP
Halts  your  program  and  returns immediately to your listing screen.

        Stop

Strings

                            {[IASC    ,4,3] =Asc     } {[IMID$   ,4,3] =Mid$    }
                            {[ICHR$   ,4,3] =Chr$    } {[IRIGHT$ ,4,3] =Right$  }
                            {[IFLIP$  ,4,3] =Flip$   } {[ISPACE$ ,4,3] =Space$  }
                            {[IINSTR  ,4,3] =Instr   } {[ISTR$   ,4,3] =Str$    }
                            {[ILEFT$  ,4,3] =Left$   } {[ISTRING$,4,3] =String$ }
                            {[ILEN    ,4,3] =Len     } {[IUPPER$ ,4,3] =Upper$  }
                            {[ILOWER$ ,4,3] =Lower$  } {[IVAL    ,4,3] =Val     }

ASC
{[RAMOSPro_Examples:Examples/H-1/Help_10.AMOS,0,4]=Asc}

Gives the Ascii code of a character.

        Print Asc("A")
CHR$
{[RAMOSPro_Examples:Examples/H-1/Help_10.AMOS,0,4]=Chr$}

Creates  a  String  containing  one  CHaRacter  whose  Ascii code number is
specified in brackets.

        s$=CHR$(number)
FLIP$
{[RAMOSPro_Examples:Examples/H-1/Help_10.AMOS,0,4]=Flip$}

FLIP$  reverses the order of the characters in your string.  So your string
is flipped from right to left.

         Print Flip$("AMOS Basic")
INSTR
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Instr}

Searches out the occurrences of a string INside another STRing.  The result
is the location of the first character in your destination string, starting
from the left.

If search has been unsuccessful, you`ll get zero.

         test=Instr("source string","search characters")

         Print Instr("AMOS Professional","AMOS")

You  can  also  start  off  the  search  from a specific position, using an
optional start parameter.

         test=Instr("source string","search characters",start)

LEFT$
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Left$}

Returns the specified number of characters from the LEFT of a string.

       l$=Left$("characters",number)
LEN
{[RAMOSPro_Examples:Examples/H-0/Help_4.AMOS,0,4]=Len}

Reads the number in characters in a string.

       length=Len("String")
LOWER$
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Lower$}

Converts all the characters in a string to LOWER case.

        low$=Lower$("CHARACTERS")

        Print Lower$("AMOS Professional")
MID$
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Mid$}

Returns a string of characters from the MIDdle of a string.

        middlebit$=Mid$("string",numbercharacters)

        Mid$(A$,position,numbercharacters)=middlebit$

RIGHT$
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Right$}

Returns a series of characters from the right-hand side of an AMOS string.

       r$=Right$("sourcestring",numbercharacters)
       Right$("sourcestring",numbercharacters)=r$
SPACE$
{[RAMOSPro_Examples:Examples/H-1/Help_10.AMOS,0,4]=Space$}

Generates a string of n spaces.

        s$=Space$(n)
STR$

{[RAMOSPro_Examples:Examples/H-0/Help_4.AMOS,0,4]=Str$}

Converts  a  number  into  a  STRing.   This  is handy for use with certain
functions  that  do  not  allow  numbers  to be used as parameters, such as
CENTRE and TEXT.

        a$=Str$(number)
STRING$
{[RAMOSPro_Examples:Examples/H-1/Help_10.AMOS,0,4]=String$}

Creates  a  new string made up of a number of copies of the original source
string.

        newstring$= String$("sourcestring",numbercharacters)
UPPER$
{[RAMOSPro_Examples:Examples/H-0/Help_2.AMOS,0,4]=Upper$}

Converts a string of text into nothing but UPPER case (CAPITAL) letters.

        capital$=Upper$("source")
VAL
{[RAMOSPro_Examples:Examples/H-0/Help_4.AMOS,0,4]=Val}

Converts a list of decimal digits stored in a string into a number

        x=Val(v$)
Array Operations

                               {[IMATCH ,4,3] =Match         }
                               {[ISORT  ,4,3] Sort           }
MATCH
{[RAMOSPro_Examples:Examples/H-0/Help_4.AMOS,0,4]=Match}

Searches  through  a  sorted array for your chosen value.  If the search is
successful,  you'll  get it's index number as the return value.  But if the
search  fails,  you'll get a NEGATIVE result instead.  This holds the index
number of the item which came closest to your search parameter muliplied by
-1.

Match works equally well with all types of arrays.  However, you'll need to
SORT the array before you make the test.  See the SORT function.

         item=Match(t(0),s)
         item=Match(t#(0),s#)
         item=Match(t$(0),s$)

SORT
{[RAMOSPro_Examples:Examples/H-0/Help_4.AMOS,0,4]Sort}

Sorts  an array in ascending order.  This array can contain either strings,
integers, or floating point numbers.

        Sort A(0)
        Sort A$(0)
        Sort A#(0)

Mathematical functions

                      {[IABS   ,4,3] Abs      } {[IHSIN,4,3] Hsin     } {[IRADIAN   ,4,3] Radian   }
                      {[IACOS  ,4,3] Acos     } {[IHTAN,4,3] Htan     } {[IRANDOMIZE,4,3] Randomize}
                      {[IATAN  ,4,3] Atan     } {[IINT ,4,3] Int      } {[IRND      ,4,3] Rnd      }
                      {[ICOS   ,4,3] Cos      } {[ILN  ,4,3] Ln       } {[ISGN      ,4,3] Sgn      }
                      {[IDEGREE,4,3] Degree   } {[ILOG ,4,3] Log      } {[ISIN      ,4,3] Sin      }
                      {[IEXP   ,4,3] Exp      } {[IMAX ,4,3] Max      } {[ISQR      ,4,3] Sqr      }
                      {[IFIX   ,4,3] Fix      } {[IMIN ,4,3] Min      } {[ISWAP     ,4,3] Swap     }
                      {[IHCOS  ,4,3] Hcos     } {[IPI# ,4,3] Pi#      } {[ITAN      ,4,3] Tan      }
DEGREE
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]DEGREE}

Allows you to enter your angles in DEGREEs rather than RADIANS.

        Degree : Print Sin(45)
RADIAN
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]RADIAN}

Enters all future angles using radians. 

        Radian

{[Iradtheory   ,4,3] More information}
Radians and angles
In  trigonometry, a radian is the angle subtended by an arc whose length is
equal  to  the  radius of a circle.  This angle is formed by two radii of a
circle  that cut off an arc on the circumference that is equal in length to
the  radius.   One radian is equal to 57.296 degrees.  The Amiga prefers to
use  radians  instead  of  degrees, but you can change that with the DEGREE
command.

PI#
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]=PI#}

Returns the number PI.  It's equal to the ratio of the diameter of a circle
to its circumference.

        Print Pi#
SIN
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]=SIN}(angle)

Calculates the SINe of an angle, resulting in a floating point number.

        a=sin(angle)

COS
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]=COS}(angle)

Returns the COSine of your angle.

        Print Cos(angle)

TAN
{[RAMOSPro_Examples:Examples/H-5/Help_58.AMOS,0,4]=TAN}(angle)
Calculates the TANgent of an angle.

        a=Tan(angle)

ACOS
{[RAMOSPro_Examples:Examples/H-5/Help_59.AMOS,0,4]=ACOS}(value)

Returns the inverse cosine of the number. 

        angle=acos(a)

You can get the Inverse SIN using:

        angle=1.5708-acos(a)
or      angle=90-acos(a) : Rem In degrees
       
ATAN
{[RAMOSPro_Examples:Examples/H-5/Help_59.AMOS,0,4]=ATAN}(value)

Returns the inverse TAN of a number

       angle=atan(a)

LOG
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=LOG}(value)

Generates the Logarithm to the Base 10 of your number or expression.

        l=log(number)
LN
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=LN}(value)

Provides the natural or naperian logarithm

        n=ln(number)

EXP
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=EXP}(value)

Generates the exponenial function

        e=EXP(number)

HSIN
{[RAMOSPro_Examples:Examples/H-5/Help_59.AMOS,0,4]=HSIN}(value)

Returns the hyperbolic Sine

        h=hsin(n)

HCOS
{[RAMOSPro_Examples:Examples/H-5/Help_59.AMOS,0,4]=HCOS}(value)

Hyperbolic cosine

        h=hcos(n)
HTAN
{[RAMOSPro_Examples:Examples/H-5/Help_59.AMOS,0,4]=HTAN}(value)

Gets the hyperbolic tangent

        h=htan(n)
RND
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]=RND}(value)

Generates  a  RaNDom  integer  between zero and your chosen number.  If you
enter a zero, the previous random value will be returned instead.

        x=Rnd(number)

RANDOMIZE
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]RANDOMIZE }value

Sets  the  seed of the random number generated by RND.  Each seed defines a
particular sequence of values.  Use RANDOMIZE TIMER for a really random set
of numbers

        randomize seed
        randomize timer
ABS
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=ABS}(value)

Gives the ABSolute value of a number, taking no account of whether it has a
positive or negative sign.  The number must be in brackets.

        Print Abs(-5)
INT
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=INT}(value)

Rounds  down  a floating point number to the nearest whole INTeger, so that
decimal numbers are changed into the nearest lower round number.

        Print Int(-6.9)
MAX
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]=MAX}(value)

Compares  expressions  made  up  of  strings, integers or real numbers, and
returns the one with the MAXimum value.

        Print Max(variable1,variable2)

MIN
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]=MIN}(value)

Compares  expressions  made  up  of  strings, integers or real numbers, and
returns the one with the MINimum value.

        Print Min$(variable1,variable2)

SGN
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=SGN}(value)

Finds the SiGN of a number:

Depending on the number, you'll get one of three possible values:

-1  if the number is negative
 0  if it's zero 
 1  if the number is positive

        s=Sgn(number)
        s=Sgn(number#)

SWAP
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]=SWAP}value1,value2

Swaps the contents of any two variable around.  Both variables should be of
exactly the same type.

        swap number1,number2
        swap float1#,float2#
        swap string1$,string2$
SQR
{[RAMOSPro_Examples:Examples/H-6/Help_60.AMOS,0,4]=SQR}(value)

Calculates  the  SQuare  Root  of  a  number,  that is the number that when
multiplied by itself results in the number you have selected in brackets.

        a#=Sqr(number)

FIX
{[RAMOSPro_Examples:Examples/H-2/Help_24.AMOS,0,4]=FIX}(value)

FIXes the precision of floating point numbers, set by the number of decimal
points wanted, specified inside brackets.

        Fix(numberdecimals) : Print Pi#

Procedures

                        {[IEND PROC  ,4,3] End Proc                     }
                        {[IGLOBAL    ,4,3] Global                       }
                        {[IPARAM    ,4,3] =Param                       }
                        {[IPARAM#   ,4,3] =Param#                      }
                        {[IPARAM$   ,4,3] =Param$                      }
                        {[IPOP PROC  ,4,3] Pop Proc                     }
                        {[IPROC      ,4,3] Proc                         }
                        {[IPROCEDURE ,4,3] Procedure                    }
                        {[ISET STACK ,4,3] Set Stack                    }
                        {[ISHARED    ,4,3] Shared                       }
END PROC
{[RAMOSPro_Tutorial:Tutorials/Procedures_1.AMOS,0,4]End Proc}

Marks  the  END  of  a  PROCedure.   Like PROCEDURE, it must occupy its own
separate line in your program.

        Procedure NAME
        : : :   Amos instructions go here
        End Proc

You can also return a value from the procedure like so:

        Endproc[number]
        Endproc[real#]
        Endproc[s$]

These  values  can be subsequently read by your program with PARAM, PARAM#,
and PARAM$ respectively.

GLOBAL
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]Global}

Defines  a  list  of  GLOBAL  variables  that can be accessed from anywhere
inside your AMOS Professional program.

        Global variable list

You  can  also define your global variables using STRINGS which can contain
the wildcards "*" or "?".

"*" means "Use any group of characters up to the next letter or number"

"?" means "Use any single character in the current position"

        Global "string"

Only string constants can used for this purpose.
PARAM
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]=Param}

Returns an integer value from the most recent AMOS procedure called by your
program.

        A=Param

The value should be returned using the ENDPROC statement in your procedure:

        Endproc[1] 
PARAM#
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]=Param#}

Returns a floating point number from the last AMOS procedure called by your
program.

        A=Param#

The value should be returned using the ENDPROC statement in your procedure:

        Endproc[1.23] 
PARAM$
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]=Param$}

Returns a string from the last AMOS procedure called by your program.

        A=Param$

The value should be returned using the ENDPROC statement in your procedure:

        Endproc["info"] 
PROC
{[RAMOSPro_Tutorial:Tutorials/Procedures_1.AMOS,0,4]Proc}

Calls  a  named procedure from your program.  It can normally be omitted.

        Proc name

Proc is often used in conjunction with the ON command to select a procedure
depending on a value entered by the user.

POP PROC
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]Pop Proc}

POPs out of a PROCedure in a hurry.

        Pop Proc

PROCEDURE
{[RAMOSPro_Tutorial:Tutorials/Procedures_1.AMOS,0,4]Procedure}

Creates an AMOS Professional PROCEDURE,identified by a string of characters
which make up its name.

        Procedure NAME

Procedures  make  programming  easier.  They are stand-alone program chunks
that  perform  a  task  without  affecting  the  main  program.  

SET STACK
Sets  the  maximum  number  of  recursive  procedure calls.  Recursion is a
clever  technique  which allows you to call a procedure from INSIDE its own
definition.   Every  time you call a procedure, AMOS allocates a set amount
of  memory  to  hold  the  local  variables.   So  if you attempt to nest a
procedure  call  more than about fifty times, you`ll run out of space.  You
can  increase this allocation with SET STACK.  Use it if you get an "out of
stack space" message.

        Set Stack maximum_no_of_recursive_procedure_calls

SHARED
{[RAMOSPro_Tutorial:Tutorials/Procedures_2.AMOS,0,4]Shared}

Called inside a procedure to allow you to access a variable from your main
program.

        Shared variable list.

You can also define your shared variables using STRINGS containing wildcards
such as "*" or "?".

"*" means "Use any group of characters up to the next letter or number"

"?" means "Use any single character in the current position"

        Shared "string"

Only string CONSTANTS can used for this purpose.


The Mouse and Joystick ports

                        {[ICHANGE MOUSE ,4,3] Change Mouse } {[ILIMIT MOUSE  ,4,3] Limit Mouse  }
                        {[IFIRE         ,4,3] =Fire        } {[IMOUSE CLICK  ,4,3] =Mouse Click }
                        {[IJDOWN        ,4,3] =Jdown       } {[IMOUSE KEY    ,4,3] =Mouse Key   }
                        {[IJLEFT        ,4,3] =Jleft       } {[IMOUSE SCREEN ,4,3] =Mouse Screen}
                        {[IJOY          ,4,3] =Joy         } {[IMOUSE ZONE   ,4,3] =Mouse Zone  }
                        {[IJRIGHT       ,4,3] =Jright      } {[ISHOW         ,4,3] Show         }
                        {[IJUP          ,4,3] =Jup         } {[ISHOW ON      ,4,3] Show On      }
                        {[IHIDE         ,4,3] Hide         } {[IX MOUSE       ,4,3] =X Mouse     }
                        {[IHIDE ON      ,4,3] Hide On      } {[IY MOUSE       ,4,3] =Y Mouse     }
CHANGE MOUSE
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]Change Mouse}

Alters  the  MOUSE  pointer  on  screen to a predefined numbered shape of 1
(arrow)  2  (crosshairs)  or 3 (clock).  Numbers 4 and over use images from
the object bank.

        Change Mouse shapenumber
FIRE
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Fire}

Tests  the  state  of  a joystick FIRE-button, returning -1 if a particular
button number has been pressed.

        x=Fire(number)
HIDE
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]Hide}

HIDEs  the mouse pointer from your screen, depending on the number of times
specified by a SHOW command.

        Hide
HIDE ON
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]Hide On}

Ensures  the  mouse  pointer  is  hidden  no  matter how many times SHOW is
called.
        Hide On
JOY
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Joy}

Reads the current status of a JOYstick.

        status=Joy(portnumber)

Portnumber number=0  checks a joystick in the mouse port.
                 =1  tests a stick in the normal joystick port.

The  status is rerurned in the form of a bitmap.If a bit is set to one, the
joystick has been moved in the relevant direction.

Here's a list of the possible return values.

            Normal              With Fire Button pressed

               1                       17
           5       9               21      25

         4     0     8           20    16     24

           6       10              22       26
               2                       18
JLEFT
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Jleft}

Returns  a  value  of True(-1) if the joystick has been pulled to the left,
otherwise zero.

        Print Jleft(portnumber)

portnumber=1 for the joystick socket, or 0 for the mouse port.
JRIGHT
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Jright}

Returns  a  value of True(-1) if the joystick has been pulled to the right,
otherwise zero.

        Print Jright(portnumber)

portnumber=1 for the joystick socket, or 0 for the mouse port.
JUP
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Jup}

Returns  a  value of True(-1) if the joystick has been yanked up, otherwise
zero.

        Print Jup(portnumber)

portnumber=1 for the joystick socket, or 0 for the mouse port.

JDOWN
{[RAMOSPro_Examples:Examples/H-6/Help_68.AMOS,0,4]=Jdown}

Returns a value of True(-1) if the joystick has been pushed down, otherwise
zero.

        Print Jdown(portnumber)

portnumber=1 for the joystick socket, or 0 for the mouse port.

LIMIT MOUSE
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]Limit Mouse}

Restricts the MOUSE movements to the LIMITs of a given rectangle on screen.
You set up the size of this rectangle by giving its coordinates.

        Limit Mouse x1,y1 To x2,y2
MOUSE CLICK
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=Mouse Click}

Checks  if  the  user  has  clicked  on  the  mouse buttons.  The result is
returned in the form of a bit pattern.

Bit 0: Set to one if the left button has been pressed. Normally zero.

Bit 1: If the Right button has ben pressed, you'll get a one in this
       position. Otherwise, zero.

After  the mouse has been tested, the bits are automatically reset to zero.
So you can only use this command to check for a SINGLE click.

Use the MOUSE KEY function if you want to test the status continuously.
MOUSE KEY
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=Mouse Key}

Reads the status of the MOUSE buttons, and tells you the result in the form
of a bit-pattern.

Bit 0: Set to one if the left button has been pressed. Normally zero.

Bit 1: If the Right button has ben pressed, you'll get a one in this
       position. Otherwise, zero.

        T=Mouse Key
MOUSE SCREEN
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]=Mouse Screen}

Checks to see which SCREEN the MOUSE pointer is currently occupying.

        screen number=Mouse Screen
SHOW
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]Show}

SHOWs  a previously hidden mouse pointer on the screen, whenever the number
of SHOWs becomes greater than the number of HIDEs already programmed.

        Show
SHOW ON
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]Show On}

Immediately  SHOWs  a  hidden  mouse  pointer on screen, no matter how many
HIDEs have been commanded.

        Show On
X MOUSE
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]=X Mouse}

Tells  you  the  hardware  X  coordinate of the MOUSE pointer.  If you give
XMOUSE  a  value then this function can also be used to move the mouse to a
specific screen position.

        X1=X Mouse
        Mouse=X1
Y MOUSE
{[RAMOSPro_Examples:Examples/H-4/Help_49.AMOS,0,4]=Y Mouse}

Tells  you  the  hardware  Y  coordinate of the MOUSE pointer.  If you give
YMOUSE  a value, then this function can also be used to move the mouse to a
specific screen position.

        Y1=Y Mouse
        Y Mouse=Y1


Memory banks

      {[IM_AS         ,4,3] As                  } {[IBSAVE      ,4,3] Bsave               } {[ILOAD                ,4,3] Load                }
      {[IBANK SHRINK,4,3] Bank Shrink         } {[IBSEND      ,4,3] Bsend               } {[IRESERVE AS CHIP DATA,4,3] Reserve As Chip Data}
      {[IBANK SWAP  ,4,3] Bank Swap           } {[IERASE      ,4,3] Erase               } {[IRESERVE AS CHIP WORK,4,3] Reserve As Chip Work}
      {[IBGRAB      ,4,3] Bgrab               } {[IERASE ALL  ,4,3] Erase All           } {[IRESERVE AS DATA     ,4,3] Reserve As Data     }
      {[IBLOAD      ,4,3] Bload               } {[IERASE TEMP ,4,3] Erase Temp          } {[IRESERVE AS WORK     ,4,3] Reserve As Work     }
      {[IBLENGTH   ,4,3] =Blength            } {[ILENGTH    ,4,3] =Length             } {[ISAVE                ,4,3] Save                }
      {[IBSTART    ,4,3] =Bstart             } {[ILIST BANK  ,4,3] List Bank           } {[ISTART              ,4,3] =Start              }

AS
{[RAMOSPro_Examples:Examples/H-7/Help_71.AMOS,0,4]As}

Used in conjunction with the RESERVE AS command.

        Reserve As Chip 1,1000

BANK SHRINK

Reduces  the size of a previously defined memory bank, returning any unused
memory to your Basic program.

        Bank Shrink bank_no To new_length

bank_no  is  an already reserved memory bank.  Note:  This instruction does
not work with object and icon banks

new_length = the new size of the bank.
It must be smaller than the Current length..
BANK SWAP
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Bank Swap}

Swaps the numbers of any two memory banks.

        Bank Swap bank1, bank2

BGRAB

Grabs  a memory bank from the previous program.The bank is now removed from
the  original  program,  and  appears  in  the  current  program bank-list,
replacing  any  bank  with the same number.  After you've finished, you can
return the bank to it's owner using BSEND.

        Bgrab bank
BLENGTH

Returns the length of a bank from program UNDERNEATH the present one.  It's
used  by  accessories  such  as  the  object editor to access the users bob
images.

You'll get a zero if the bank has not been defined in the previous program,
or there's no other program in memory.  (PRG UNDER=0)

        l=Blength(bank)
BLOAD
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Bload}

LOADs Binary data into a specified address or bank number.

        Bload file$,address 
BSAVE
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Bsave}

SAVEs a block of memory stored between a start and end location, to a named
file.  The data is saved as it stands with no special formatting.

        Bsave file$, start TO end   
BSEND

Transfers  a  bank from the current program to the previous program.  It is
the  exact opposite of BGRAB.  The bank disappears from the current program
bank-list, and appears in the previous program list, replacing any existing
data.

        Bsend bank 
BSTART

Returns the address of a bank from a previous program, if possible.  You'll
get  an error if a bank hasn't been reserved in the previous program.  (PRG
UNDER=0)

        address =Bstart(bank)   
ERASE
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Erase}

Deletes the contents of the memory bank whose number you specify.

        Erase banknumber
ERASE ALL

Clears ALL banks from memory

        Erase All 
ERASE TEMP

Erases ALL temprorary or WORK banks in your current program

        Erase Temp
LENGTH
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]=Length}

Returns  the LENGTH of a memory bank in bytes.  If it contains images, then
the number of objects in the bank will be given instead.

        Print Length(banknumber)
LIST BANK
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]=Listbank}

Provides  a  detailed  LISTing of the memory BANKs currently reserved.  The
following  information will be shown about each bank:  its number, the type
of bank, its start address in hexadecimal and its length.

        List Bank
LOAD
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Load}

LOADs one or more memory banks from the disc.  An optional destination bank
can be included if required.

        Load "filename.abk"

Loads all the banks from filename.abk

        Load "filename.abk",number

Loads just a single bank.

RESERVE AS CHIP DATA
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Reserve As Chip Data}

Creates a permanent memory bank using CHIP ram.

        Reserve As Chip Data banknumber,length

This bank will be automatically saved with your program.
RESERVE AS CHIP WORK
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Reserve As Chip Work}

Creates a temporary memory bank of the required length using CHIP ram.

        Reserve As Chip Work banknumber,length

RESERVE AS DATA
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Reserve As Data}

RESERVEs a permanent bank of memory using FAST ram if it's available.

        Reserve As Data banknumber,length

This bank will be automatically saved with your program.

RESERVE AS WORK
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Reserve As Work}

RESERVEs a temporary memory bank using FAST ram where possible.

        Reserve As Work banknumber,length
SAVE
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]Save}

SAVEs all memory banks onto disc.  If an optional bank number is specified,
only that bank number will be saved.

        Save "filename.abk",number
START
{[RAMOSPro_Examples:Examples/H-7/Help_78.AMOS,0,4]=Start}

Returns the START address of your chosen memory bank.

        Print Start(banknumber)
Hardware Sprites

                  {[IDEL SPRITE        ,4,3] Del Sprite        } {[ISPRITE PRIORITY   ,4,3] Sprite Priority   }
                  {[IGET SPRITE        ,4,3] Get Sprite        } {[ISPRITE UPDATE     ,4,3] Sprite Update     }
                  {[IGET SPRITE PALETTE,4,3] Get Sprite Palette} {[ISPRITE UPDATE OFF ,4,3] Sprite Update Off }
                  {[IHOT SPOT          ,4,3] Hot Spot          } {[ISPRITE UPDATE ON  ,4,3] Sprite Update On  }
                  {[II SPRITE          ,4,3] I Sprite          } {[IX SPRITE         ,4,3] =X Sprite         }
                  {[IINS SPRITE        ,4,3] Ins Sprite        } {[IX HARD           ,4,3] =X Hard           }
                  {[ISET SPRITE BUFFER ,4,3] Set Sprite Buffer } {[IX SCREEN         ,4,3] =X Screen         }
                  {[ISPRITE            ,4,3] Sprite            } {[IY SPRITE         ,4,3] =Y Sprite         }
                  {[ISPRITE BASE       ,4,3] Sprite Base       } {[IY HARD           ,4,3] =Y Hard           }
                  {[ISPRITE OFF        ,4,3] Sprite Off        } {[IY SCREEN         ,4,3] =Y Screen         }

DEL SPRITE
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Del Sprite}

Deletes one or more sprite images completely from the object bank.

        Del Sprite n

n is the number of the image you wish to remove from the bank.

If  you  want to erase several objects, you can use the second form of this
instruction.

        Del Sprite f To l

The command will now delete all the images from f to l.
GET SPRITE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Get Sprite}

Grabs  a  section  from a screen of given coordinates and loads it into the
Object  bank.   An  optional  screen  number  can be given before the image
number.  This allows you to grab your images from any existing AMOS screen.

        Get Sprite screen number,image number,x1,y1 To x2,y2

GET SPRITE PALETTE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Get Sprite Palette}

Copies  the  colour  values  used  by  your sprite images straight into the
current screen.

        Get Sprite Palette

The  optional  mask  allows  you  to  limit yourself to just a selection of
colours.

        Get sprite Palette bitmask

Each  colour is represented by a single digit in a 32 digit "bit mask".  If
the digit's set to 1, then the appropriate colour value will be copied over
from the sprite bank.

HOT SPOT
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Hot Spot}

Positions the reference point for all coordinate calculations.

        Hot Spot image,x,y

Automatically adds x and y to the sprite coordinates before use.

        Hot Spot image,p

p moves the hotspot to one of of 9 pre-set positions

$00  $10  $20
$01  $11  $21
$02  $21  $22
I SPRITE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]=I Sprite}

Returns the current Image number used by sprite s.

The result will be zero if the sprite is not visible on the current display.

        Image=I Sprite(s)
INS SPRITE
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Ins Sprite}

        Ins Sprite n

Inserts  a  blank  image at position n in the current object bank.  All the
images after this number are moved down a place.

        Ins Sprite f To l

Creates  several  image  slots  in  a  single operation.  A series of blank
spaces will now be created between image number f and image l.

SET SPRITE BUFFER

{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Set Sprite Buffer}

Allocates extra memory for the hardware and computed sprites to work with.

AMOS  initially  reserves  just  enough  memory for a maximum of 128 lines.
This can be easily increased to a larger value, such as 256.

        Set Sprite Buffer lines
SPRITE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Sprite}

        Sprite s,hx,hy,image

Loads  sprite  s with your image and positions it at your selected HARDWARE
coordinates x,y.

The sprite number s can be anything from 0 to 63. 

Sprites 0 to 7 generate hardware sprites

numbers 8 through 63 use computed sprites.

SPRITE BASE

        n=Sprite Base(number)

Provides the address of the internal data list for Sprite number.

SPRITE OFF
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]Sprite Off}

Removes one or more sprites from the screen.

        Sprite Off

Kills ALL active sprites

       Sprite Off s

Turns off sprite number s
SPRITE PRIORITY

Controls the way your sprites are displayed on a Dual playfield screen.

        Sprite Priority n

n sets the priority of the sprites relative to the two playfields.

The  following  table  should  make  this clearer.  Objects with the higher
order value are always displayed in front of those with a lower one.

n         Playfield Sprites 0/1  Sprites 2/3  Sprites 4/5  Sprites 6/7
0  Order     4         3            2            1             0
1            3         4            2            1             0
2            2         4            3            1             0
3            1         4            3            2             0
4            0         4            3            2             1
SPRITE UPDATE
{[RAMOSPro_Tutorial:Tutorials/Computed_Sprites.AMOS,0,4]Sprite Update}

Performs  all  sprite  movements  in  a  single  burst.   Before using this
command, you'll need to switch off the automatic display system with SPRITE
UPDATE OFF.

        Sprite Update
        Wait Vbl

The  WAIT VBL command is important, as it synchronises the sprite movements
with the screen updates.

SPRITE UPDATE OFF 
{[RAMOSPro_Tutorial:Tutorials/Computed_Sprites.AMOS,0,4]Sprite Update Off}

Stops  sprites  from  being redisplayed on the screen immediately when they
are  moved  to  a  new  position.  Use it with the SPRITE UPDATE command to
generate exceptionally smooth object movements.

        Sprite Update Off
SPRITE UPDATE ON
{[RAMOSPro_Tutorial:Tutorials/Computed_Sprites.AMOS,0,4]Sprite Update On}

Reverses the effect of a previous SPRITE UPDATE OFF command and forces your
sprites to be automatically redrawn when they are moved.

        Sprite Update On
X HARD
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=X Hard}

Converts  an  X  coordinate  relative to the current screen into a HARDware
coordinate.

         hx=X Hard(xcoordinate)

If  an  optional  screen  number  is  given,  then  all coordinates will be
relative to the selected screen.

        hx=X Hard(screen number,xcoordinate)

X SCREEN
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=X Screen}

Converts  a  hardware X coordinate into a SCREEN coordinate relative to the
present screen.

        sx=X Screen(hx)

If  you  include  an  optional  screen  number  in  this  function, the new
coordinate will be relative to your chosen screen.

        sx=X Screen(screen number,hx)
X SPRITE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]=X Sprite}

Returns  the  X  coordinate  of  one of your AMOS Basic sprites in Hardware
format.
          hx=X Sprite(s)
Y HARD
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=Y Hard}

Converts  a  Y  coordinate  relative to the current screen into a HARDware
coordinate.

        hy=Y Hard(ycoordinate)

If  an  optional  screen  number  is  given,  then  all coordinates will be
relative to the selected screen.

        hy=Y Hard(screen number,ycoordinate)

Y SCREEN
{[RAMOSPro_Examples:Examples/H-5/Help_50.AMOS,0,4]=Y Screen}

Converts  a  Y  coordinate  in  hardware  format  into  a SCREEN coordinate
relative to the present screen.

        sy=Y Screen(hy)

If  you  include  an  optional  screen  number  in  this  function, the new
coordinate will be relative to your chosen screen.

        sy=Y Screen(screen number,hy)
Y SPRITE
{[RAMOSPro_Tutorial:Tutorials/Hardware_Sprites.AMOS,0,4]=Y Sprite}

Returns  the  Y  coordinate  of  one of your AMOS Basic sprites in Hardware
format.

        hy=Y Sprite(s)


Blitter Objects

                {[IBOB                  ,4,3] Bob                  } {[IPASTE BOB            ,4,3] Paste Bob            }
                {[IBOB OFF              ,4,3] Bob Off              } {[IPRIORITY OFF         ,4,3] Priority Off         }
                {[IDEL BOB              ,4,3] Del Bob              } {[IPRIORITY ON          ,4,3] Priority On          }
                {[IDOUBLE BUFFER        ,4,3] Double Buffer        } {[IPRIORITY REVERSE OFF ,4,3] Priority Reverse Off }
                {[IGET BOB              ,4,3] Get Bob              } {[IPRIORITY REVERSE ON  ,4,3] Priority Reverse On  }
                {[IGET BOB PALETTE      ,4,3] Get Bob Palette      } {[IREV                 ,4,3] =Rev                 }
                {[IHREV                ,4,3] =Hrev                } {[IPUT BOB              ,4,3] Put Bob              }
                {[II BOB               ,4,3] =I Bob               } {[ISET BOB              ,4,3] Set Bob              }
                {[IINS BOB              ,4,3] Ins Bob              } {[IVREV                ,4,3] =Vrev                }
                {[ILIMIT BOB            ,4,3] Limit Bob            } {[IX BOB               ,4,3] =X Bob               }
                {[INO MASK              ,4,3] No Mask              } {[IY BOB               ,4,3] =Y Bob               }

BOB
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]Bob}

Draws a Blitter OBject at the given coordinates on the current screen. 

        Bob number,x,y,imagenumber
BOB OFF
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Bob Off}

Removes  a  numbered Blitter OBject from the screen, or removes all Bobs if
you leave out the individual number.

        Bob Off bobnumber
DEL BOB
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Del Bob}

Deletes one or more bob images completely from the object bank.

        Del Bob n

n is the number of the image you wish to remove from the bank.

If  you  want  to  erase several objects, you can use a second form of this
instruction.

        Del Bob f To l

The command will now delete all the images from f to l.
DOUBLE BUFFER
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]Double Buffer}

Creates a DOUBLE screen BUFFER, as an invisible copy of the current screen.
It's vital for flicker free animation!

See SCREEN SWAP, LOGIC and PHYSIC.

        Double Buffer
GET BOB
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Get Bob}

Grabs  a  section  from a screen of given coordinates and loads it into the
Object  bank.   An  optional  screen  number  can be given before the image
number.  This allows you to grab your images from any existing AMOS screen.

        Get Bob screen number,image number,x1,y1 To x2,y2
GET BOB PALETTE

Loads  all  of  your  Blitter  OBject  colours  to  the current screen.  An
optional mask can be used to load a selection of these colours at a time.

        Get Bob Palette,mask
HREV
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]=Hrev}

Flips a Bob image from left to right. Any hot spots will also be reversed.

        Bob number,x,y,image number : Rem Normal image
        Rem Now flip this image number horizontally
        Bob number,x,y,HREV(image number)
I BOB
{[RAMOSPro_Examples:Examples/H-2/Help_27.AMOS,0,4]= I Bob}

Returns  the  current  Image  number  used by Blitter OBject number b.  The
result will be zero if the bob is not visible on the current display.

        Image=I Bob(b)
INS BOB
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Ins Bob}

Inserts  a  blank  image at position n in the current object bank.  All the
images after this number will be moved down a place.

        Ins Bob n

        Ins Bob f To l

Creates  several  image  slots  in  a  single operation.  A series of blank
spaces will now be created between image number f and image l.

LIMIT BOB
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Limit Bob}

Restricts  the  visibility  of a numbered Blitter OBject to the LIMITs of a
rectangle  on  screen.   You  set  up  the size of this rectangle by simply
entering its coordinates.

        Bob 1,100,100,1
        Limit Bob number,x1,y1 To x2,y2
NO MASK
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]No Mask}

Removes the blitter mask around one or all bobs.  Without a mask, the Bob's
entire image will be displayed on screen, including any transparent bits in
colour zero.

         No Mask : Rem Removes ALL blitter masks
         No Mask object : Rem Kills the mask around the selected bob
PASTE BOB
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]Paste Bob}

Gets  an  image  from the OBject bank, then PASTEs it on the screen at your
chosen coordinates.

        Paste Bob x,y,imagenumber
PRIORITY ON
{[RAMOSPro_Examples:Examples/H-3/Help_30.AMOS,0,4]Priority On}

Normally  Bobs  barge  in  front  of  any  objects with a lower Bob number.
PRIORITY  ON  gives  the  greatest  priority  to objects with the highest y
coords on the screen.

        Priority On

PRIORITY OFF
{[RAMOSPro_Examples:Examples/H-3/Help_30.AMOS,0,4]Priority Off}

Displays  all  Bobs  on  the  screen  in  strict order of their Bob number.
(default)

        Priority Off

PRIORITY REVERSE ON
{[RAMOSPro_Examples:Examples/H-3/Help_30.AMOS,0,4]Priority Reverse On}

Activates  the  REVERSE  effect  of the PRIORITY command for the display of
Bobs on screen.  PRIORITY REVERSE OFF is the normal mode, but by turning it
ON  Bobs  with  the lowest y coordinates will appear in front of those with
higher y coordinates.

        Priority Reverse On

PRIORITY REVERSE OFF
{[RAMOSPro_Examples:Examples/H-3/Help_30.AMOS,0,4]Priority Reverse Off}

Resets the Priority system to normal.

        Priority Reverse Off
PUT BOB 
{[RAMOSPro_Examples:Examples/H-2/Help_28.AMOS,0,4]Put Bob}

Fixes  a  copy  of  the bob n at it's current position on the screen.  Your
copy  will  remain  firmly in place when the bob moves away.  Always follow
this command with a WAIT VBL.

       Put Bob n
REV
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]=Rev}

REVerses a Bob image completely, by flipping it over its own horizontal and
vertical axis.  Any hot spots will also be reversed.

        Bob number,x,y,image number : Rem Normal image
        Rem Now flip this image number completely
        Bob number,x,y,REV(image number)
SET BOB
{[RAMOSPro_Examples:Examples/H-2/Help_27.AMOS,0,4]Set Bob}

SETs the mode for drawing a Blitter OBject on screen.

        Set Bob number,background,screenplanes,mask

number is the number of the bob you want to affect.

background can take one of three values:

             0  replaces the background whenever the bob is moved. (Default)

Greater than 0  replaces the area with a block of colour background-1

   Less than 0  doesn't redraw the background at all.

screenplanes  is  a bit-pattern which specifies which planes are to be used
by the bob.  A value of 1 draws the bob in plane, a zero doesn't.

mask selects the blitter mode using a set of minterms.
VREV
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]=Vrev}

Turns a Bob image upside down. Any hot spots will also be reversed.

        Bob number,x,y,image number : Rem Normal image
        Rem now flip this image number vertically
        Bob number,x,y,VREV(imagenumber)
X BOB
{[RAMOSPro_Examples:Examples/H-2/Help_27.AMOS,0,4]=X Bob}

Returns the X coordinate of your bob on the current screen.

        x1=X Bob(number)
Y BOB
{[RAMOSPro_Examples:Examples/H-2/Help_27.AMOS,0,4]=Y Bob}

Returns the Y coordinate of your bob on the current screen.

        y1=Y Bob(number)

Detecting Collisions
                          {[IBOB COL      ,4,3] =Bob Col                 }
                          {[IBOBSPRITE COL,4,3] =Bobsprite Col           }
                          {[ICOL          ,4,3] =Col                     }
                          {[IHARDCOL      ,4,3] =Hardcol                 }
                          {[ISET HARDCOL   ,4,3] Set Hardcol              }
                          {[ISPRITE COL   ,4,3] =Sprite Col              }
                          {[ISPRITEBOB COL,4,3] =Spritebob Col           }
                          {[IMAKE MASK     ,4,3] Make Mask                }

COL
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]=Col}

Checks  for  the other objects involved in a collision you've just detected
using one of the BOB COL,SPRITE COL, BOBSPRITE COL and SPRITEBOB COL
functions.

target is the number of the object you wish to test.  If it's collided with
your source object, you'll get a value of -1, otherwise 0 will be returned.

        c=Col(target)

If  you  enter  a  target  of  -1, AMOS will return the number of the FIRST
object which has collided with your source object.

BOB COL
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]=Bob Col}

Detects  COLlisions between one or more blitter objects.  If a collision is
detected,  BOB  COL  will  return  a value of -1.  Otherwise you'll get a 0
instead.

        c=Bob Col(source)

If  you  want  to  restrict  your test to just a selection of bobs, you can
optionally extend the BOB COL command like so:

        c=Bob Col(source,first TO last)
BOB SPRITE COL
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]=Bobsprite Col}

Tests  a single BOB for a collision with a group of sprites.  A value of -1
signifies  that the test was successful.  You can now immediately check for
the other objects involved in the collision using the COL function.

        c=Bob Sprite Col(bobnumber)

Note  that ALL the sprites you are testing MUST have a blitter mask.  These
are created using the MAKE MASK command.

You can also use a second version of this function.

         c=Bob Sprite Col(bobnumber,first TO last)

Tests for collisions between the source Bob and Sprites from first to last.

HARD COL
Returns the result of the hardware collision detector you've activated with
the  SET  HARDCOL command.  If the test is successful you'll get a value of
True (-1).  Otherwise the result will be False (0).

You can now find the identification number of any other sprites involved in
the collision using the COL function as normal.

        test=Hardcol(spritenumber)
MAKE MASK
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]Make Mask}

Makes  a blitter mask for all the objects on the screen, including sprites.
This  command  should  be  used  before  any  collision  detection routines
involving sprites.

          Make Mask
          Make Mask n : Rems Makes a mask around sprite n
SET HARDCOL
Activate the Amiga's built-in hardware collision detector.  This allows you
to  check  for the collison between a Hardware sprite (0 to 7) and any part
of the screen background.

         Set Hardcol enablebits,comparisonbits
SPRITE COL
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]=Sprite Col}

Looks for collisions between several sprites.  These sprites MUST have been
previously initialised with the MAKE MASK option.

        c=Sprite Col(source)

If  another sprite has collided with your source object, you'll get a value
of -1.  Otherwise the result will be zero.

There's also a more selective version of this function.

        c=Sprite Col(source,first TO last)

Only checks for collisions between the source object and sprites from first
to last.  (See COL,MAKE MASK)

SPRITEBOB COL
{[RAMOSPro_Tutorial:Tutorials/Collision_Detection.AMOS,0,4]=Spritebob Col}

Checks  a  single  SPRITE  for collisions between several bobs.  The source
sprite MUST have been assigned a mask with the MAKE MASK option before use.

If the test is successful, you'll get a result of -1.  You can now find the
other objects in the collision with a call to the COL function.

        c=Sprite Bob Col(spritenumber)

There's also an extended version of this function.

        c=Sprite Bob Col(spritenumber,first To last)

Tests for collisions between the source object and bobs from first to last.
(See COL,MAKE MASK)

Setting up screens

   {[IAUTOVIEW ON     ,4,3] Autoview On     } {[IDISPLAY HEIGHT ,4,3] =Display Height } {[ISCREEN          ,4,3] Screen          } {[ISCREEN HIDE     ,4,3] Screen Hide     }
   {[IAUTOVIEW OFF    ,4,3] Autoview Off    } {[IDUAL PLAYFIELD  ,4,3] Dual Playfield  } {[ISCIN           ,4,3] =Scin           } {[ISCREEN OFFSET   ,4,3] Screen Offset   }
   {[ICLS             ,4,3] Cls             } {[IDUAL PRIORITY   ,4,3] Dual Priority   } {[ISCREEN         ,4,3] =Screen         } {[ISCREEN OPEN     ,4,3] Screen Open     }
   {[ICOLOUR          ,4,3] Colour          } {[IGET PALETTE     ,4,3] Get Palette     } {[ISCREEN COLOUR  ,4,3] =Screen Colour  } {[ISCREEN SHOW     ,4,3] Screen Show     }
   {[ICOLOUR          ,4,3] =Colour         } {[ILOAD IFF        ,4,3] Load Iff        } {[ISCREEN CLONE    ,4,3] Screen Clone    } {[ISCREEN TO BACK  ,4,3] Screen To Back  }
   {[ICOLOUR BACK     ,4,3] Colour Back     } {[INTSC           ,4,3] =Ntsc           } {[ISCREEN CLOSE    ,4,3] Screen Close    } {[ISCREEN TO FRONT ,4,3] Screen To Front }
   {[IDEFAULT         ,4,3] Default         } {[IPALETTE         ,4,3] Palette         } {[ISCREEN DISPLAY  ,4,3] Screen Display  } {[ISCREEN WIDTH   ,4,3] =Screen Width   }
   {[IDEFAULT PALETTE ,4,3] Default Palette } {[ISAVE iFF        ,4,3] Save Iff        } {[ISCREEN HEIGHT  ,4,3] =Screen Height  } {[IVIEW            ,4,3] View            }

AUTOVIEW ON
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]Autoview On}

Restarts  the  normal  automatic  viewing  mode for your screens.  Your new
screens  will  now be displayed straight after they've been created, at the
next vertical blank.

        Auto View On
AUTOVIEW OFF
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]Autoview Off}

Activates  manual  viewing mode.  In manual mode, your new screens are only
displayed  when  you  specifically request an update using VIEW.  Use it as
part  of your programs initialisation procedure to generate your display in
the background.

       Auto View Off
CLS
{[RAMOSPro_Examples:Examples/H-3/Help_39.AMOS,0,4]Cls}

CLears all or part of a Screen in one of three ways:

        Cls

Clears entire screen using the current paper colour.

        Cls colour

Clears screen using the selected colour index.

        Cls colour,tx,ty To bx,yb

Erases the block from tx,ty to bx,by
COLOUR
{[RAMOSPro_Examples:Examples/H-0/Help_5.AMOS,0,4]Colour}

Reads or changes the colour value assigned to one of your colour indexes.

        Colour indexnumber,$RGB

Changes  a colour in the palette, by setting the strength of its Red, Green
and Blue components.

        c=Colour(index)

Returns  the hexadecimal colour value held in one of your colour indexes as
a proportion of Red, Blue amd Green components.
        
        Print Hex$(Colour(Index))

COLOUR BACK
{[RAMOSPro_Examples:Examples/H-0/Help_5.AMOS,0,4]Colour Back}

Changes the colour of the display where no screens exist (dead area).

        Colour Back $RGB
DEFAULT
{[RAMOSPro_Examples:Examples/H-3/Help_38.AMOS,0,4]Default}

Resets  the  display  screen  to its original DEFAULT setting of 320 pixels
wide, 200 pixels high and 16 colours, and closes any other open screens.

DEFAULT PALETTE
{[RAMOSPro_Examples:Examples/H-3/Help_38.AMOS,0,4]Default Palette}

Defines  a list of colours which will be used by each new screen you create
with SCREEN OPEN.

        Default Palette c1,c2,c3,c4,,,,

DISPLAY HEIGHT
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]=Display Height}

Returns the HEIGHT of your screen DISPLAY in pixels.

        Print Display Height

DUAL PLAYFIELD
{[RAMOSPro_Examples:Examples/H-3/Help_37.AMOS,0,4]Dual Playfield}

Displays  two  screens  on top of each  other.   Colour  zero is treated as
transparent,  so  anything  drawn in it to the first screen will reveal the
appropriate region of the second.

       Dual playfield screen1,screen2 

Each screen can use up to eight colours. 
DUAL PRIORITY
{[RAMOSPro_Examples:Examples/H-3/Help_37.AMOS,0,4]Dual Priority}

Allows  you to reverse the order of the two screens used to generate a dual
playfield.

       Dual Priority screen1,screen2

Displays screen 1 over screen 2
GET PALETTE
{[RAMOSPro_Examples:Examples/H-3/Help_38.AMOS,0,4]Get Palette}

Copies  the PALETTE of colours from a numbered screen and loads them to the
current screen.

        Get Palette sourcescreen

An  optional mask can be used to load a selection of these colours from the
source.

        Get Palette sourcescreen,mask
LOAD IFF
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]Load Iff}

LOADs an IFF format graphic to your current screen.If you want to choose an
alternative destination screen, simply enter its number after the filename.

        Load iff "filename"
        Load Iff "filename",screen number

NTSC
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]=Ntsc}

Reports back which screen mode AMOS Professional is running under.

0 means PAL is active and -1 means NTSC is being used.
PALETTE
{[RAMOSPro_Examples:Examples/H-0/Help_5.AMOS,0,4]Palette}

Sets  any combination of current screen colours from the available PALETTE.
Colours  are made up using hexadecimal notation, making it easier to define
the RGB of a colour.

        Palette $RGB,$RGB,$RGB
SAVE IFF
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]Save Iff}

SAVEs the current screen as an IFF picture on your disc.

        Save Iff "filename"

A  compression  code  can  be  used  as an option for compacting the screen
before  it is saved.  This code is set to zero to save the screen as it is,
or set to 1 to use the standard file compression system for saving memory.

        Save Iff "filename",compressioncode
SCIN
{[RAMOSPro_Examples:Examples/H-3/Help_36.AMOS,0,4]=SCIN}

Returns the number of an AMOS screen at your selected hardware coordinates.

        s=SCIN(hx,hy)

If a screen isn't defined at these coordinates, you'll get a value of zero.
SCREEN
{[RAMOSPro_Examples:Examples/H-3/Help_39.AMOS,0,4]Screen}

This comes in two flavours:

        Screen number

Selects  a  SCREEN for all future graphics and text operations, even if the
screen is hidden away in the background.

        s=Screen

Returns  the  number  of the current screen you are using for your text and
graphics operations.

{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]=Screen}

SCREEN CLONE
{[RAMOSPro_Examples:Examples/H-3/Help_36.AMOS,0,4]Screen Clone}

Makes  an  exact  CLONEd copy of the current SCREEN and assigns it to a new
screen number.

        Screen Clone number
SCREEN CLOSE
{[RAMOSPro_Examples:Examples/H-3/Help_34.AMOS,0,4]Screen Close}

Erases your SCREEN and frees up its memory for the rest of your program.

        Screen Close number
SCREEN COLOUR
{[RAMOSPro_Examples:Examples/H-3/Help_36.AMOS,0,4]=Screen Colour}

Returns the maximum number of colours available from the current screen.

        Print Screen Colour 

SCREEN DISPLAY
{[RAMOSPro_Examples:Examples/H-3/Help_34.AMOS,0,4]Screen Display}

Sets the position of your SCREEN on the display.

        Screen Display number,x,y,width,height

x,y enter the position in hardware coordinates

width,height specify the size of the screen area to be displayed.
SCREEN HEIGHT
{[RAMOSPro_Examples:Examples/H-3/Help_36.AMOS,0,4]=Screen Height}

Returns the height of the current screen in lines.

       Print Screen Height
SCREEN HIDE
{[RAMOSPro_Examples:Examples/H-3/Help_37.AMOS,0,4]Screen Hide}

HIDEs a SCREEN invisibly away in the background.

        Screen Hide

Hides the current screen

        Screen Hide screennumber

Hides screennumber

The screen can be redisplayed using the SCREEN SHOW command.
SCREEN OFFSET
{[RAMOSPro_Examples:Examples/H-3/Help_34.AMOS,0,4]Screen Offset}

Changes  the  position  of  the  first pixel to be displayed on the screen.
This allows you to scroll a large screen neatly through the display area.

        Screen Offset number,x,y
SCREEN OPEN
{[RAMOSPro_Examples:Examples/H-3/Help_34.AMOS,0,4]Screen Open}

OPENs a new AMOS SCREEN on the display. 

        Screen Open number,width,height,colours,mode

number ranges from 0 to 7.

width and height set the size of the screen in pixels.

colours enter the number of colours to be used.

mode sets the screen mode. Allowable options include Lowres,Hires, and Laced.
SCREEN SHOW

{[RAMOSPro_Examples:Examples/H-3/Help_37.AMOS,0,4]Screen Show}

SHOWs a SCREEN that has been previously hidden from view with SCREEN HIDE.

        Screen Show number
SCREEN TO BACK
{[RAMOSPro_Examples:Examples/H-3/Help_39.AMOS,0,4]Screen To Back}

Moves a SCREEN to the back of your display.

        Screen To Back

Affects the current screen

        Screen To Back number

Moves another screen to the back instead.
SCREEN TO FRONT

{[RAMOSPro_Examples:Examples/H-3/Help_39.AMOS,0,4]Screen To Front}

Moves a SCREEN to the front of your display.

        Screen To Front

Affects the current screen

        Screen To Front number

Moves another screen to the front instead.
SCREEN WIDTH
{[RAMOSPro_Examples:Examples/H-3/Help_36.AMOS,0,4]Screen Width}

Returns the width in pixels of the current screen.

        Print Screen Width
VIEW
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]View}

VIEWs  all  screens which have changed since the last update.  This is used
with  the  AUTO  VIEW  OFF  feature  to  display your new AMOS screens at a
particular point in your program.

        View
Screen effects

                {[IAPPEAR       ,4,3] Appear        } {[IFLASH        ,4,3] Flash         } {[ISCREEN SWAP  ,4,3] Screen Swap   }
                {[ICOP LOGIC    ,4,3] =Cop Logic    } {[IFLASH OFF    ,4,3] Flash Off     } {[ISCREEN BASE ,4,3] =Screen Base  }
                {[ICOP MOVE     ,4,3] Cop Move      } {[ILOGBASE     ,4,3] =Logbase      } {[ISCROLL       ,4,3] Scroll        }
                {[ICOP MOVEL    ,4,3] Cop Movel     } {[ILOGIC       ,4,3] =Logic        } {[ISET RAINBOW  ,4,3] Set Rainbow   }
                {[ICOP RESET    ,4,3] Cop Reset     } {[IPACK         ,4,3] Pack          } {[ISHIFT DOWN   ,4,3] Shift Down    }
                {[ICOP SWAP     ,4,3] Cop Swap      } {[IPHYBASE     ,4,3] =Phybase      } {[ISHIFT OFF    ,4,3] Shift Off     }
                {[ICOP WAIT     ,4,3] Cop Wait      } {[IPHYSIC      ,4,3] =Physic       } {[ISHIFT UP     ,4,3] Shift Up      }
                {[ICOPPER OFF   ,4,3] Copper Off    } {[IRAIN        ,4,3] =Rain         } {[ISPACK        ,4,3] Spack         }
                {[ICOPPER ON    ,4,3] Copper On     } {[IRAINBOW      ,4,3] Rainbow       } {[IUNPACK       ,4,3] Unpack        }
                {[IDEF SCROLL   ,4,3] Def Scroll    } {[IRAINBOW DEL  ,4,3] Rainbow Del   } {[IWAIT VBL     ,4,3] Wait Vbl      }
                {[IFADE         ,4,3] Fade          } {[ISCREEN COPY  ,4,3] Screen Copy   } {[IZOOM         ,4,3] Zoom          }


APPEAR
{[RAMOSPro_Tutorial:Tutorials/Appear.AMOS,0,4]Appear}

Slowly fades from one screen to another using a range of fancy effects.

        Appear source To destination,effect

effect  sets  the  type of fade ranging from 1 to the maximum number of the
pixels on your screen.

        Appear source To destination,effect,pixels

pixels  enters  the  number of screen points to be affected by the command.
It defaults to the entire screen area.

COP  LOGIC
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop  Logic}

Returns the absolute address of the logical copper list in memory.

        address=Cop Logic
COP MOVE
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop Move}

Inserts a "MOVE" command into the current logical copper list.

        Cop Move addr,value
COP MOVEL
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop Movel} 

Generates a matched pair of "MOVE" commands in the new copper list.

        Cop Movel addr,value

COP RESET
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop Reset}

Adds a pair of "Move" commands which forces the copper list to restart from
the very first instruction.  You can use this to generate simple loops.

        Cop Reset

COP SWAP 
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop Swap}

Switches  the  logical  and  physical copper lists around.  Your new copper
list  will  now be flicked neatly into place.  You'll see the results after
the next vertical blank.

        Cop Swap
        Wait Vbl
COPPER OFF
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Copper Off}

Freezes  the  automatic  copper  generation which forms the mainstay of the
AMOS Graphics system.  Once it's turned off, you're on your own!

        Copper OfF
COPPER ON
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Copper On}

Restarts the standard copper calculations and returns your AMOS screen back
to normal.

COP WAIT
{[RAMOSPro_Examples:Examples/H-6/Help_62.AMOS,0,4]Cop Wait}

Enters a "WAIT" instruction at the current point in your copper list.

        Cop Wait x,y

x can be a hardware coordinate from 0 to 448. 
y can be any value from 0 to 312.

         Cop Wait x,y,xmask,ymask

xmask  and  ymask  are  bitmasks  which  allow you to wait until the screen
coordinates satisfy a specific combination of bits.  They default to $1FF.

DEF SCROLL
{[RAMOSPro_Examples:Examples/H-3/Help_38.AMOS,0,4]Def Scroll}

Defines  a scrolling zone on the current screen.  This zone can be scrolled
through the display using the SCROLL command.

        Def Scroll z,tx,ty to bx,by,dx,dy

z is the scroll zone from 1 to 16.

tx,ty are the coordinates of the top left hand corner of the zone.

bx,y hold the coordinates of the point dialogonally opposite.

dx,dy enters the distance in pixels to be moved right or down in each scroll.
FADE
{[RAMOSPro_Tutorial:Tutorials/fade.AMOS,0,4]Fade}

Fades a selected range of colours onto the screen.

        Fade speed

Slowly reduces all the colour values down to zero (black).

speed holds the delay in 50th of a second between each step.

        Fade Speed To $RGB,$RGB...

Fades  using a list of colour values, separated by commas.  You can include
as  many  values  as  you  like.   Providing  you  keep the commas in their
original positions, you can also omit colours from the fade. Eg. 
Fade 10 To 1,,3, : Rem only affects colours 0 and 2

  
        Fade speed To screen number 


Fades the colours into the colour palette used by the selected AMOS Screen. 
A value of -1 fades the colours from the Sprite Palette instead.

        Fade speed To screen,number,mask 

mask is an optional bit-pattern specifying which colours are to be changed.
Bit 0 affects the first colour, bit 1 the second etc.

FLASH
{[RAMOSPro_Examples:Examples/H-2/Help_25.AMOS,0,4]Flash}

FLASH  automatically  flicks  a  selected  colour through a range of values
using interrupts.

        Flash index,"(RGB,delay)(RGB,delay)"

index enters the  colour to be changed.

RGB holds a new colour value in Red Green Blue format.

delay  sets the period this colour will be held on the screen in 50ths of a
second.              

FLASH OFF
{[RAMOSPro_Examples:Examples/H-2/Help_25.AMOS,0,4]Flash Off}

Turns off an animated colour sequence created with the FLASH command.

        Flash Off
LOGBASE
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]=Logbase}

Returns  the  address  of  one of the six possible bit-planes making up the
current  LOGical  screen.   If  the  plane  does  not exist, a zero will be
returned.

        address=Logbase(planenumber)
=LOGIC
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]=Logic}

Returns  the  identification number of the LOGICal screen.  This number can
be used in conjunction with SCREEN COPY,APPEAR or ZOOM.

        Print Logic
PACK
{[RAMOSPro_Examples:Examples/H-4/Help_41.AMOS,0,4]Pack}

Compresses any part of an AMOS screen into a memory bank.

        Pack screennumber To banknumber,tx,ty,bx,by

tx,ty hold the coordinates of the top left of the area to be packed.

bx,by specify the point diagonally opposite. 
=PHYBASE
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]=Phybase}

Returns  the  address  of  one of the six possible bit-planes making up the
current  PHYsical  screen.   If  the  plane  does  not  exist, zero will be
returned.

        address=Phybase(planenumber)
PHYSIC
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]=Physic}

Returns  the identification number of the PHYSICal screen.  This number can
be used in conjunction with SCREEN COPY,APPEAR or ZOOM.

        I=Physic
RAIN
{[RAMOSPro_Tutorial:Tutorials/Rainbows.AMOS,0,4]Rain}

Sets the colour of an individual RAINbow line on the screen. 

        A=Rain(rnumber,line)

rnumber is the number of a rainbow created with the SET RAINBOW command.

line is the number of the rainbow line you wish to change, from 0 to 270.
RAINBOW
{[RAMOSPro_Tutorial:Tutorials/Rainbows.AMOS,0,4]Rainbow}

Creates an attractive RAINBOW effect using the values you've defined using 
SET RAINBOW or the RAIN function.

        Rainbow rnumber,base,y,height

rnumber is the number of the rainbow from 0 to 3.

base  is an offset to the first colour in the rainbow table to be displayed
on the screen.

y enters the vertical position of the rainbow as a hardware coordinate.

height sets the height of the rainbow in scan lines.
RAINBOW DEL
{[RAMOSPro_Tutorial:Tutorials/Rainbows.AMOS,0,4]Rainbow Del}

DELetes one or more RAINBOWs.

        Rainbow Del

Erases ALL current rainbow definitions,

        Rainbow Del rnumber

Deletes a single rainbow.
SCREEN BASE
{[RAMOSPro_Examples:Examples/H-6/Help_64.AMOS,0,4]Screen Base}

Returns the BASE address of the SCREEN table that is used to hold a list of
dimensions and statistics about your AMOS Professional screens.

        table=Screen Base
SCREEN COPY
{[RAMOSPro_Examples:Examples/H-3/Help_39.AMOS,0,4]Screen Copy}

Copies  a  selected area of the screen from one place to another, using the
Amiga's amazing Blitter Chip.

        Screen Copy screen1 To screen2

Copies an entire screen.

screen1 holds the source image

screen2 sets the number of the destination screen.  


        Screen Copy screen1,tx,ty,bx,by To screen2,sx,sy,mode

Copies just part of a screen.

tx,ty enter the coordinates of the top left of the source image

bx,by specify the point diagonally opposite. 

sx,sy choose the top left-hand coordinates of the destination.


        Screen Copy screen1,tx,ty,bx,by To screen2,sx,sy,mode

Copies using a special blitter mode.

Try mode values like: %11100000, %00110000, %01100000
SCREEN SWAP
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]Screen Swap}

SWAPs  the display between the current logical and physical components of a
double  buffered screen.  The old physical screen is hidden away in memory,
and the logical one is flicked onto the display.

        Screen Swap

If  you  have  several  double  buffered  screens,  you can use an extended
version of this command.

        Screen Swap screennumber
SCROLL
{[RAMOSPro_Examples:Examples/H-3/Help_38.AMOS,0,4]Scroll}

Scrolls  the screen using the settings you have previously specified in the
DEF SCROLL command.

        Scroll z

Where z is the number of your scrolling zone.
SET RAINBOW
{[RAMOSPro_Tutorial:Tutorials/Rainbows.AMOS,0,4]Set Rainbow}

SETs up a RAINBOW effect for later display.

        Set Rainbow rnumber,colour,length,r$,g$,b$

rnumber is the number of your rainbow from 0 to 3

colour is an index to be assigned to your effect.

length enters the size of the table used to store your rainbow colours from
16 to 65500.

R$,G$,B$  give  the red, green and blue intensities of your colour bands in
the format (lines,step,count)

SHIFT UP
{[RAMOSPro_Examples:Examples/H-2/Help_25.AMOS,0,4]Shift Up}

Rotates a colour upwards through the current screen palette.

        Shift Up delay,first,last,flag

first  and last choose the range of colour indexes which will be rotated by
your instruction.

delay sets the delay in fiftieths of a second between each colour shift. 

type =1 cycles the colours continuosly.
     =0 discard the colour value of index last after each rotation.
SHIFT DOWN
{[RAMOSPro_Examples:Examples/H-2/Help_25.AMOS,0,4]Shift Down}

Rotates a colour downwards through the current screen palette.

        Shift Down delay,first,last,flag

first  and last choose the range of colour indexes which will be rotated by
your instruction.

delay sets the delay in fiftieths of a second between each colour shift. 

type =1 cycles the colours continuosly.
     =0 discard the colour value of index first after each rotation.

SHIFT OFF
{[RAMOSPro_Examples:Examples/H-2/Help_25.AMOS,0,4]Shift Off}

Turns off a colour rotation generated by the SHIFT UP or SHIFT DOWN 
commands.

        Shift Off
SPACK
{[RAMOSPro_Examples:Examples/H-4/Help_41.AMOS,0,4]Spack}

Performs  a  Screen  PACK  and  saves it into a memory bank.  The graphics,
screen  modes  and  all  location  details  are saved together, ready to be
unpacked at a later date.

        Spack screennumber To Banknumber

Packs an entire screen

        Spack screennumber To banknumber,tx,ty,bx,by

Compresses the region from tx,ty to bx,by
UNPACK
{[RAMOSPro_Examples:Examples/H-4/Help_41.AMOS,0,4]Unpack}

UNPACKs a compacted screen in one of three ways.

        Unpack banknumber To screennumber

Opens a screen and restore its image from the memory bank.

        Unpack banknumber

Unpacks a screen at its original position.

        Unpack banknumber,x,y

Unpacks an image and redraws it starting at coordinates x,y
WAIT VBL
{[RAMOSPro_Examples:Examples/H-4/Help_40.AMOS,0,4]Wait Vbl}

Stops  and WAITs until the next Vertical BLank period, the 50th of a second
it takes to update a screen.  This is ideal for synchronising animation and
screen swaps.

        Wait Vbl
ZOOM
{[RAMOSPro_Examples:Examples/H-7/Help_77.AMOS,0,4]Zoom}

Magnifies or reduces a section of the screen by ZOOMing in or out.

        Zoom source,stx,sty,sbx,sby To destination,dtx,dty,dbx,dby

Takes  an image from stx,sty to sby,sby and copies it to the region dtx,dty
to  dbx,dby.   If the destination area is larger than the source, the image
will  be  expanded  in  order  to  fit.  If it's smaller, the image will be
reduced.


Graphics
                   {[IBAR        ,4,3] Bar               } {[IPLOT       ,4,3] Plot              }
                   {[IBOX        ,4,3] Box               } {[IPOLYGON    ,4,3] Polygon           }
                   {[ICIRCLE     ,4,3] Circle            } {[IPOLYGON TO ,4,3] Polygon To        }
                   {[ICLIP       ,4,3] Clip              } {[IPOLYLINE   ,4,3] Polyline          }
                   {[IDRAW       ,4,3] Draw              } {[IPOLYLINE TO,4,3] Polyline To       }
                   {[IDRAW TO    ,4,3] Draw To           } {[ISET LINE   ,4,3] Set Line          }
                   {[IELLIPSE    ,4,3] Ellipse           } {[ISET PAINT  ,4,3] Set Paint         }
                   {[IGR LOCATE  ,4,3] Gr Locate         } {[ISET PATTERN,4,3] Set Pattern       }
                   {[IGR WRITING ,4,3] Gr Writing        } {[ISET SLIDER ,4,3] Set Slider        }
                   {[IHSLIDER    ,4,3] Hslider           } {[ISET TEMPRAS,4,3] Set Tempras       }
                   {[IINK        ,4,3] Ink               } {[IVSLIDER    ,4,3] Vslider           }
                   {[IPAINT      ,4,3] Paint             } {[IX GR       ,4,3] =X Gr             }
                   {[IPOINT      ,4,3] =Point            } {[IY GR       ,4,3] =Y Gr             }
BAR
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Bar}

Draws a filled rectangle at your chosen screen coordinates.

        Bar x1,y1 To x2,y2
BOX
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Box}

Draws a hollow rectangle from x1,y1 to x2,y2

        Box x1,y1 To x2,y2
CIRCLE
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Circle}

Draws an empty CIRCLE with its centre at coordinates x,y and with a radius r.

        Circle x,y,r
CLIP
{[RAMOSPro_Examples:Examples/H-0/Help_9.AMOS,0,4]Clip}

Limits all drawing operations to a specified screen area.

       Clip x1,y1 To x2,y2

DRAW
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Draw}

Draws  a  line between the starting and ending coordinates.  Parameters can
be omitted if required.

        Draw x1,y1 To x2,y2
DRAW TO
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Draw To}

Draws  a  line  from  the  current  graphic  cursor  location  to  your new
coordinates.

        Draw To x3,y3
ELLIPSE
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Ellipse}

Draws  an  outlined  ELLIPSE at your chosen coordinates, with the specified
horizontal and vertical radii.

        Ellipse x,y,radius1,radius2

GR LOCATE
{[RAMOSPro_Examples:Examples/H-0/Help_6.AMOS,0,4]Gr Locate}

Positions  the  GRaphics  cursor at your new coordinates before you start a
drawing operation.

        Gr Locate x,y
GR WRITING
{[RAMOSPro_Examples:Examples/H-0/Help_9.AMOS,0,4]Gr Writing}

Gives a choice of several alternative GRaphics WRITING modes.

        Gr Writing bitpattern

Bit 0

=0, only the graphics set to the current ink colour will be drawn.
=1, new images will completely replace existing images.
    This is the normal setting. 

Bit 1

=1, new images will be combined with existing images. 

Bit 2

=1, all new images will be drawn in "inverse video", which means that 
    the current ink colour will appear as the current paper colour and 
    vice versa.
HSLIDER
{[RAMOSPro_Examples:Examples/H-3/Help_33.AMOS,0,4]Hslider}

Draws  a  horizontal  slider  bar  on the screen.  With a little work, it's
possible  to  animate  this  to  generate  attractive  scroll bars for your
program.

        Hslider tx,ty To bx,by,total,pos,size

total sets  the number of units the bar is divided into.

pos specifies the postion of the slider box relative to the start of 
    the bar, in the units your entered in total.

size fixes the size of the slider box.
INK
{[RAMOSPro_Examples:Examples/H-0/Help_5.AMOS,0,4]Ink}

Defines  the colour to be used by all future drawing operations. 

        Ink colournumber

There are two optional parameters that you can tack on, a background colour
and a border colour.
          
        Ink colournumber,backgroundnumber

        Ink colournumber,backgroundnumber,bordernumber
PAINT
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Paint}

Fills  an  area  starting at coordinates x,y with your chosen INK colour or
pattern.

        Paint x,y

        Paint x,y,mode


mode = 0 painting stops wherever the current border colour is found.
     = 1 stops at the first pixel different from the current INK.
PLOT
{[RAMOSPro_Examples:Examples/H-0/Help_6.AMOS,0,4]Plot}

Draws  a point in the current ink colour at your choice of coordinates.  If
you  want,  a  new colour can be specified, which will be used for this and
all further drawing operations.

        Plot x,y,colour
POINT
{[RAMOSPro_Examples:Examples/H-0/Help_6.AMOS,0,4]=Point}

Returns  the  colour index of a single screen POINT.  You'll get a NEGATIVE
value if the point lies outside the current screen area.

        Print Point(x,y)
POLYGON
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Polygon}

Draws  a  filled POLYGON, or many sided shape using the current ink colour.
The shape of the polygon is set up with a list of screen coordinates.

        Polygon x1,y1 To x2,y2 To x3,y3 To ...
POLYGON TO
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Polygon To}

Draws a filled polygon starting from the current graphics cursor position.

         Plot x1,y1
         Polygon To x2,y2 To x3,y3 To ...
POLYLINE
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Polyline}

Draws  a  hollow  polygon  using  the current ink colour.  The shape of the
polygon is set up with a list of screen coordinates.

        Polyline x1,y1 To x2,y2 To x3,y3 To ...
POLYLINE TO
{[RAMOSPro_Examples:Examples/H-0/Help_7.AMOS,0,4]Polyline To}

Draws a hollow polygon starting from the current graphics cursor position.

         Plot x1,y1
         Polyline To x2,y2 To x3,y3 To ...
SET LINE
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Set Line}

SETs  the  appearance of all straight LINEs to be drawn using DRAW and BOX.
A mask must be set after SET LINE in the form of a 16-bit binary number.

        Set Line %1111000011110000 : Rem Dotted line
        Set Line %1111111111111111 : Rem Normal line
SET PAINT
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Set Paint}

SETs the outline mode for shapes drawn using BAR and POLYGON.  A mode value
of  1  creates  a  border  line of the last INK colour, and a value of zero
turns the outline off again.

        Set Paint modenumber
SET PATTERN
{[RAMOSPro_Examples:Examples/H-0/Help_8.AMOS,0,4]Set Pattern}

SETs  the  PATTERN  to  be  used  for  filling shapes by choosing a pattern
number.   A  value  of  zero  is the normal setting, which completely fills
shapes  with the current INK colour.  If the pattern number is greater than
zero,  one  of  the  built-in patterns is used.  If it is less than zero, a
clipped version of one of your Bobs will be adapted as your fill pattern.

        Set Pattern number
SET SLIDER
{[RAMOSPro_Examples:Examples/H-3/Help_33.AMOS,0,4]Set Slider}

Sets the style of a slider bar created with VSLIDER or HSLIDER.

        Set Slider bink,bpaper,bout, bpatt,sink, spaper,sout,spatt

bink,bpaper,bout  enter  the  colours for the ink,paper, and outline of the
slider.

bpattern specifies the fill pattern to be used.

sink,spaper,sout,spatt define the appearance of the slider box inside.
SET TEMPRAS
{[RAMOSPro_Examples:Examples/H-0/Help_9.AMOS,0,4]Set Tempras}

Sets the location and size of the temporary memory area used by your graphics
operations.

        Set Tempras address,size
VSLIDER
{[RAMOSPro_Examples:Examples/H-3/Help_33.AMOS,0,4]Vslider}

Draws a vertical slider bar on the screen.

        Vslider tx,ty To bx,by,total,pos,size

total sets the number of units the bar is divided into.

pos  specifies  the position of the slider box relative to the start of the
bar, in the units you've entered in total.

size fixes the size of the slider box.

Menus
  {[IBANK TO MENU     ,4,3] Bank To Menu     } {[IMENU DEL         ,4,3] Menu Del         } {[IMENU MOUSE ON    ,4,3] Menu Mouse On    } {[IMENU TO BANK     ,4,3] Menu To Bank     }
  {[ICHOICE          ,4,3] =Choice          } {[IMENU INACTIVE    ,4,3] Menu Inactive    } {[IMENU MOVABLE     ,4,3] Menu Movable     } {[ION MENU          ,4,3] On Menu          }
  {[IMENU$           ,4,3] =Menu$=          } {[IMENU ITEM MOVABLE,4,3] Menu Item Movable} {[IMENU OFF         ,4,3] Menu Off         } {[ION MENU DEL      ,4,3] On Menu Del      }
  {[IMENU ACTIVE      ,4,3] Menu Active      } {[IMENU ITEM STATIC ,4,3] Menu Item Static } {[IMENU ON          ,4,3] Menu On          } {[ION MENU OFF      ,4,3] On Menu Off      }
  {[IMENU BAR         ,4,3] Menu Bar         } {[IMENU KEY         ,4,3] Menu Key         } {[IMENU ONCE        ,4,3] Menu Once        } {[ION MENU ON       ,4,3] On Menu On       }
  {[IMENU BASE        ,4,3] Menu Base        } {[IMENU LINE        ,4,3] Menu Line        } {[IMENU SEPARATE    ,4,3] Menu Separate    } {[ISET MENU         ,4,3] Set Menu         }
  {[IMENU CALC        ,4,3] Menu Calc        } {[IMENU LINK        ,4,3] Menu Link        } {[IMENU STATIC      ,4,3] Menu Static      } {[IX MENU          ,4,3] =X Menu          }
  {[IMENU CALLED      ,4,3] Menu Called      } {[IMENU MOUSE OFF   ,4,3] Menu Mouse Off   } {[IMENU TLINE       ,4,3] Menu Tline       } {[IY MENU          ,4,3] =Y Menu          }


                           {[IHelpEmbeddedmenu,4,3] Embedded Menu Commands }
BANK TO MENU
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_8.AMOS,0,4]Bank To Menu}

Restores a menu definition you've previously set up in the menu bank.

        Bank To Menu bank number

You can activate your menu using the MENU ON instruction.
CHOICE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_1.AMOS,0,4]=Choice}

If  you use CHOICE on it's own, it returns a value of True (-1) if the user
has selected a menu item, or false if the menu hasn't been accessed.

         test=Choice

There's  also  a  second  version  which allows you to read the actual item
which has been chosen.

         test=Choice(level)

test  holds  the number of the item which has been highlighted by the user.
level is the "dimension" of the menu to be tested.

Level 1 = the title line

Levels 2 through 8 read a submenu at the appropriate level.
MENU ACTIVE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Active}

Re-activates  a  set of menu items which have been greyed out with the MENU
INACTIVE instruction.

        Menu Active level

Activates an entire level.

        Menu Active(a,b,c)

Activates  a single item.  The position of the item in the menu tree is set
with  a list of index numbers such as 1,2,3.  Depending on the type of your
menu, you can include as many as eight parameters.

        Menu Active(1,2)
        Menu Active(1,2,3,4,5)
MENU BAR
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Bar}

Displays  your menu as a vertical BAR, with each item in your list directly
below the previous one.

        Menu Bar level

Sets an entire level.

        Menu Bar(a,b,...)

Sets an individual menu item.
MENU BASE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]Menu Base}

Moves your menu to a new position on the screen.

        Menu Base x,y

MENU CALC
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_8.AMOS,0,4]Menu Calc}

Calculates  the  new  state  of your menu after it's been changed.  This is
normally  automatic,  but you can take control using MENU OFF to perform it
directly at the most convenient point in your program.

        Menu Calc

After the calculation has been performed you can now safely restart the menu
with MENU ON.
MENU CALLED
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]Menu Called}

Redraws  your  menu  fifty  times  a  second whenever it's displayed on the
screen.   It's  used  in  conjunction  with  the  embedded menu commands to
generate terrific animated menu items.

        Menu Called(a,b...)
MENU DEL
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_4.AMOS,0,4]Menu Del}

Erases the selected menu items from the Amiga's memory.

        Menu Del

Deletes the Entire menu.

        Menu Del(a,b..)

Erases a single menu item.
MENU INACTIVE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Inactive}

"greys  out"  a  series of options from the menu.  These items can still be
selected, but they won't return a value to your AMOS program.

        Menu Inactive level

Disables an entire level of your menu.

       Menu Inactive(a,b,..)

Turns off a single menu item.
MENU ITEM MOVABLE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Item Movable}

Re-positions  individual  menu  items  anywhere  on the display.  It's used
after a MENU MOVABLE command to add extra flexibility to your menus.

      Menu Item Movable level

Makes all items at the current level movable

      Menu Item Movable(a,b,..)

Makes a single item movable.
MENU ITEM STATIC
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Item Static}

Locks  a menu item firmly into position, so that it can't be dragged by the
user.  These static menus are just like the standard AMOS Editor menu.

      Menu Item Static level

Fixes all items at the current level

      Menu Item Static(a,b,..)
     
Locks a single item into place. 
MENU KEY
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_4.AMOS,0,4]Menu Key}

Assigns  a  key-press  to any individual menu item.  This is interpreted by
the  Menu  system  exactly as if the user had selected the option directly
from the menu.


        Menu Key(a,b,..) To c$

Assign a single key-press in c$ to the item at a,b,..

        Menu Key(a,b,..) To scancode

        Menu Key(a,b,..) To scancode,shift

See KEY SHIFT for a list of the various shift options.
MENU LINE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Line}

Displays  your  menu items in the form of a horizontal line stretching from
the  top left hand corner of the first menu item to the bottom right of the
last one.

       Menu Line level

Displays the current level as a line

       Menu Line(a,b,..)

Displays individual elements of a sub-menu as a line.
MENU LINK
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Link}

Links one or more menu items together, so that they are moved or display as
a group.

       Menu Link level
       Menu Link(a,b,..)
MENU MOUSE OFF
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Mouse Off}

Deactivates the automatic menu movements generated by MENU MOUSE ON.

      Menu Mouse Off
MENU MOUSE ON
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Mouse On}

From  now  on, the menu will be positioned directly under the mouse pointer
whenever  it's  displayed on the screen.  This mode can be deactivated with
MENU MOUSE OFF.

        Menu Mouse On
MENU MOVABLE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Movable}

Allows  you to move selected menus directly with the mouse.  If you wish to
manipulate  the individual menu items directly, you'll need to use the MENU
ITEM MOVABLE command as well.

        Menu Movable Level

Makes an entire level movable

        Menu Movable(a,b,..)

Makes a single sub-menu movable
MENU OFF
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_1.AMOS,0,4]Menu Off}

Temporarily freezes the action of your entire menu.  Any attempt to display
it on the screen will be ignored.

        Menu Off

The menu can be restarted with a call to MENU ON.
MENU ON
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_1.AMOS,0,4]Menu On}

Activates  a  menu which has been previously defined in your program.  This
menu  will  be  displayed  on the screen when the user holds down the RIGHT
mouse button.

        Menu On

Starts up a menu created with MENU$

        Menu On bank

Activates a menu held in a menu bank.
MENU ONCE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]Menu Once}

Deactivates  the  automatic  redrawing  process  started using MENU CALLED.
From  now on, the menu item will only be display ONCE when it's called onto
the screen.

        Menu Once(a,b,..)
MENU SEPARATE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Separate}

Tells  AMOS  to  separate all the menu items at the current level.  So each
item is treated independently of any of it's neighbours.

        Menu Separate Level
        Menu Separate(a,b,..)
MENU STATIC
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Static}

Fixes the current menu firmly into it's present position.

        Menu Static level

Makes all the menus at the selected level completely immovable.

        Menu Static(a,b,..)

Affects a single sub-menu.
MENU TLINE
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_6.AMOS,0,4]Menu Tline}

Displays a section of the menu on a horizontal bar stretching from the left
of the screen to the far right.  It's just like a normal title line.

        Menu Tline level

Displays the entire level as a TLINE

        Menu Tline(a,b,..)

Sets a single sub-menu.
MENU TO BANK
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_8.AMOS,0,4]Menu To Bank}

Saves  all the current menu definitions into the selected AMOS memory bank.
This  bank  can  be subsequently saved on the disc, and reloaded to provide
you  with instant access to your menu.  It can be started up using the MENU
ON command.

        Menu To Bank banknumber

These banks can also be created using the Menu_Bank_Editor.AMOS utility
on the AMOSPro Productivity disc 1.
MENU$
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_1.AMOS,0,4]=Menu$}

MENU$  is  a  special  pseudo-variable which allows you to create your AMOS
Menus directly inside one of your programs.

        Menu$(,,)=normal$
        Menu$(,,)=normal,selected$
        Menu$(,,)=normal,selected$,inactive$
        Menu$(,,)=normal,selected$,inactive$,background$

normal$ holds the description of the normal menu item.

selected$ sets appearance of an item when it's highlighted by the user.

inactive$ enters the description of an inactive item.

background$ defines the background area of your items.

These strings can contain either plain text or embedded Menu commands.


{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_2.AMOS,0,4] Menu Hierarchy}
ON MENU
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_3.AMOS,0,4]On Menu}

Automatically  jumps to an appropriate Procedure, or Label depending on the
menu  title selected by the user.  This routine can then check out the item
number using the CHOICE function.

There are three separate forms of this command.

        On Menu Proc proc1,proc2..

        On Menu Gosub label1,label2...

        On Menu Goto label1,label2...

This  feature  needs  to be activated using the ON MENU ON command prior to
use.   Also  note  that  before  returning to AMOS Basic, your procedure or
routine  MUST  perform an  ON MENU ON  to  restart  the  testing process.
Otherwise the menus will be deactivated after the first menu call.

ON MENU DEL
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_3.AMOS,0,4]On Menu Del}

Deletes the internal labels used by ON MENU and allows you to redirect your
menus  to  another  part  of  your program.  Before using this command, you
should  turn  off  the Menu selection with ON MENU OFF.  You can then use a
further ON MENU command to set up your new menu actions.

        On Menu Del
ON MENU OFF
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_3.AMOS,0,4]On Menu Off}

Temporarily  halts  the  automatic  menu selection generated by the ON MENU
commands.  Your menus can be restarted again with a call to ON MENU ON.

        On Menu Off
ON MENU ON
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_3.AMOS,0,4]On Menu On}

Activates  the  automatic  menu  system created by the ON MENU instruction.
This  function  should  always  be  used  just  before  leaving  your  menu
procedures  or  sub-routines.  Otherwise the menus will be turned off after
the initial call.

        On Menu On
SET MENU
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]Set Menu}

SET MENU sets the position of any movable menu item on the screen.

        Set Menu(a,b,..) To x,y

All coordinates are measured relative to the previous menu level.
X MENU
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]=X Menu}

Returns the X coordinate of a menu item relative to the previous menu level.

        xc=X Menu(a,b,,)
Y MENU
{[RAMOSPro_Tutorial:Tutorials/Menus/Menus_7.AMOS,0,4]=Y Menu}

Returns the Y coordinate of a menu item relative to the previous menu level.

        yc=Y Menu(a,b,,)



Updating Objects

                           {[IAUTOBACK        ,4,3] Autoback               }
                           {[IBOB CLEAR       ,4,3] Bob Clear              }
                           {[IBOB DRAW        ,4,3] Bob Draw               }
                           {[IBOB UPDATE      ,4,3] Bob Update             }
                           {[IBOB UPDATE OFF  ,4,3] Bob Update Off         }
                           {[IBOB UPDATE ON   ,4,3] Bob Update On          }
                           {[IFREEZE          ,4,3] Freeze                 }
                           {[IUPDATE          ,4,3] Update                 }
                           {[IUPDATE OFF      ,4,3] Update Off             }
                           {[IUPDATE ON       ,4,3] Update On              }
                           {[IUNFREEZE        ,4,3] Unfreeze               }
AUTOBACK
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Autoback}

Sets the automatic screen copying mode used by double buffered screens.

Mode number 0 sends all graphics to the logical screen.

Mode  1  performs each graphical operation to both the physical and logical
screens.

Mode 2 (default) combines all drawing operations with the Bob updates.

        Autoback modenumber

BOB CLEAR
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Bob Clear}

Removes  all  active  bobs  from  the  screen,  and  redraws the background
graphics on the display.  It is used with BOB DRAW.

        Bob Clear
BOB DRAW
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Bob Draw}

Called  after  a  BOB CLEAR command, which removes all active Bobs from the
logical  screen.   BOB  DRAW  then lists all Bobs that have moved since the
previous  update,  saves  the background beneath the new screen coordinates
and  then  redraws  all  active  Bobs at their new positions on the logical
screen.

        Bob Draw
BOB UPDATE
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Bob Update}

Redraws  all the Bobs at their new positions, in one smooth operation.  The
affect will only be seen after the next vertical blank.

        Bob Update : Wait Vbl
BOB UPDATE OFF
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Bob Update Off}

Turns  off any automatic screen operations and allows Bobs to be redrawn at
the required timing using BOB UPDATE.(See SCREEN SWAP and WAIT VBL)

         Bob Update Off
BOB UPDATE ON
{[RAMOSPro_Tutorial:Tutorials/Autoback_&_Update.AMOS,0,4]Bob Update On}

Activates the automatic bob operations.

        Bob Update On


UPDATE
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]Update}

Redraws  all  the objects on the screen in a single go.  It's really just a
combination  of  BOB  UPDATE  and  SPRITE  UPDATE commands.  Add a WAIT VBL
command to ensure a smooth effect.

        Update
UPDATE OFF
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]Update Off}

Turns  off  the  automatic  redrawing  system.   Any Bob commands or Sprite
operations will now appear to be totally ignored!  But never fear.  They're
still going on in the background.

        Update Off

UPDATE ON
{[RAMOSPro_Examples:Examples/H-2/Help_26.AMOS,0,4]Update}

Returns the object movement system back to it's original, automatic mode.

        Update On


IFF animation

                          {[IFRAME LENGTH,4,3] =Frame Length             }
                          {[IFRAME LOAD  ,4,3] =Frame Load               }
                          {[IFRAME PARAM ,4,3] =Frame Param              }
                          {[IFRAME PLAY  ,4,3] =Frame Play               }
                          {[IFRAME SKIP  ,4,3] =Frame Skip               }
                          {[IIFF ANIM    ,4,3] =Iff Anim                 }
                          {[IMASK IFF     ,4,3] Mask Iff                  }
                          {[IPICTURE     ,4,3] =Picture                  }

FRAME LENGTH
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]=Frame Length}

Calculates  the  amount of memory which will be needed to hold the selected
frames of an IFF animation file.

          size=Frame Length(file)

file  is  the  channel number of an IFF file which you've previously opened
with the OPEN IN command.

          size=Frame Length(file,n)

n  specifies the number of frames which should be taken into consideration.
If it's omitted, AMOS will only check out the first frame in the animation.
And  if the number's too large, AMOS will return the memory required for all
the frames in the current file.

FRAME LOAD
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]Frame Load}

Loads one or more IFF frames straight into the Amiga's memory.

frames=Frame Load(file TO bank/address,n)

file  is  the channel number of a currently open animation file.  This MUST
have previously been opened using the OPEN IN command.

bank / address is either a bank number (1-65535) or a memory address. 

n  chooses  the number of animation frames which are to be loaded.  If your
request  is  greater  than  the total number of available frames, AMOS will
automatically load all the images in the current file.

FRAME PARAM
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]=Frame Param}

Returns the amount of time which will be needed to successfully display the
animation  on the screen, measured in 1/50ths of a second.  It's used after
a  FORM  PLAY  or  FORM SKIP to delay the program until the screen has been
totally redrawn.

        param=Frame Param

        Wait Frame Param+1
FRAME PLAY
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]Frame Play}

Plays selected frames of a previously loaded IFF animation on the screen.

        next=Frame Play(bank/address,n[,screen])

bank/address  is  a  memory  address  (or  bank  number) containing an IFF
animation  sequence  which  has  been previously loaded with the FRAME LOAD
instruction.

n is the number of frames you wish to play.

         next=Frame Play(bank/address,n,screen])

screen enters a new screen to be created for your animation.
FRAME SKIP
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]Frame Skip}

Skips  past the selected frames, and returns the address of the next one in
the animation sequence.

       next=Frame Skip(bank/address)

bank/address  is  number  of a bank or the address of a valid IFF animation
frame.

       next=Frame Skip(bank/address,n)

n holds the number of frames to be skipped. It defaults to one.

next returns the address of the following animation frame.
IFF ANIM
{[RAMOSPro_Tutorial:Tutorials/Iff_Animation.AMOS,0,4]=Iff Anim}

Loads an IFF animation sequence from the disc and plays it on the screen.

        Iff Anim "filename" To screen

"filename" is the name of the animation file you wish to display. 

screen  chooses a new AMOS screen which will be created especially for your
animation  sequence.   If  the  requested  screen  already  exists, it will
automatically be replaced by your new definition.

        Iff Anim "filename" To screen,times

times  sets  the  number  of  times you wish to repeat the animation on the
screen.  If it's omitted, the animation will be displayed exactly once.

MASK IFF
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]Mask Iff}

Masks  your  IFF  picture data, setting the parts of the file which will be
loaded  from  your animation.  It's normally used with the LOAD IFF command
like so:

        Mask Iff bitmap
        Load Iff "animation"
PICTURE
{[RAMOSPro_Examples:Examples/H-3/Help_35.AMOS,0,4]=Picture}

Returns the mask defined by the current IFF image.

        bitmask=Picture : Rem Read the mask details
        Mask Iff Picture : Rem Use it for the the present animation

Using the AMOS Animation Language (AMAL)
                {[IAMAL         ,4,3] Amal                 } {[ICHANAN      ,4,3] =Chanan              }
                {[IAMAL FREEZE  ,4,3] Amal Freeze          } {[ICHANMV      ,4,3] =Chanmv              }
                {[IAMAL OFF     ,4,3] Amal Off             } {[IMOVE FREEZE  ,4,3] Move Freeze          }
                {[IAMAL ON      ,4,3] Amal On              } {[IMOVE OFF     ,4,3] Move Off             }
                {[IAMALERR      ,4,3] Amalerr              } {[IMOVE ON      ,4,3] Move On              }
                {[IAMPLAY       ,4,3] Amplay               } {[IMOVON       ,4,3] =Movon               }
                {[IAMREG        ,4,3] Amreg                } {[IMOVE X       ,4,3] Move X               }
                {[IANIM         ,4,3] Anim                 } {[IMOVE Y       ,4,3] Move Y               }
                {[IANIM FREEZE  ,4,3] Anim Freeze          } {[ISYNCHRO      ,4,3] Synchro              }
                {[IANIM OFF     ,4,3] Anim Off             } {[ISYNCHRO OFF  ,4,3] Synchro Off          }
                {[IANIM ON      ,4,3] Anim On              } {[ISYNCHRO ON   ,4,3] Synchro On           }
                {[ICHANNEL      ,4,3] Channel              } {[IUPDATE EVERY ,4,3] Update Every         }

                            {[IHelpAmalins,4,3] Amal Instructions }
AMAL
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_1.AMOS,0,4]Amal}

Assigns  a  list  of  instructions  to  an  AMAL  animation channel.  These
channels  can  be  independantly  assigned to either a Sprite, a Bob, or an
entire screen using the CHANNEL command.

        Amal channel number,"instruction string"

Takes your instructions from a string.

        Amal channel number,program

Reads an AMAL program from a special AMAL memory bank.

        Amal channel number,address

Loads the animation commands from the chosen address.

        Amal channel number,"instruction string" To address

Sends the output of your animation string to your chosen address.
AMALERR
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]=Amalerr}

Returns the position of an error in one of your animation strings.

        Print Amalerr
AMAL FREEZE 
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]Amal Freeze}

Suspends your AMAL programs and stops them running on the screen.  They can
be restarted again using the AMAL ON command.

        Amal Freeze

Freezes ALL current AMAL programs.

        Amal Freeze channel number

Halts just a single animation channel.
AMAL OFF
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]Amal Off}

Stops  one or more AMAL programs PERMANENTLY.  You'll have to redefine them
from scratch with AMAL to get them running again.

        Amal Off
AMAL ON
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_1.AMOS,0,4]Amal On}

Starts an AMAL program you've set up previously with the AMAL directive.

        Amal On

Activates ALL AMAL programs simultaneously.

        Amal On channel number

Fires up a single animation sequence.

AMPLAY
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Amplay}

Controls  a  movement pattern generated by the AMAL PLay instruction.  This
pattern  should  have been previously created from the AMAL EDITOR utility,
and should be ready and waiting in memory

        Amplay speed,direction

speed sets the playback speed in movements per second. Default=1.

direction >0 for the original setting
          =0 to reverse the movement
          -1 to stop the animation at the next movement

        Amplay speed,direction,first channel To last channel

Changes the settings in a range of animation sequences simultaneously.
AMREG
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_3.AMOS,0,4]=Amreg}

Reads or writes to an AMAL register variable.

        value=Amreg(global register)
        Amreg(global register)=value

Accesses  a global register from RA to RZ.  The register number is entered
using a simple code.  RA is checked using a 0, RB=1 and so on until RZ=25.

You  can  also  use  an  extended form of this function to get at the local
variables.

        value=Amreg(channel number,local variable)
        Amreg(channel number,local variable)=value

local variable is the number of your variable from 0 (R0) to 9 (R9)
ANIM
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Anim}

Generates a STOS compatible animation sequence.

        Anim channel number,"(image,delay)..(image,delay)"

image = the number of an image from the object bank.

delay = the period it should be displayed in units of a 50th of a sec.

The animation will only take effect when it's activated using ANIM ON.
ANIM FREEZE
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Anim Freeze}

Suspends  one  or  more  ANIM sequences.  They can be restarted again using
ANIM ON.

        Anim Freeze

Halts ALL STOS compatible animations.

        Anim Freeze channel number

Freezes a single animation sequence.
ANIM OFF
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Anim Off}

Terminates an animation sequence created with the ANIM command.

        Anim Off

Kills ALL Anim sequences.

        Anim Off channel number

Stops a single sequence.
ANIM ON
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Anim On}

Starts an animation sequence you've defined using the ANIM instruction.

        Anim On
CHANAN
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]=Chanan}

Checks if an AMAL animation sequence is still running.

        test=Chanan(channel number)

Returns True (-1) is the animation is still active, and False (0) if it has
finished.
CHANMV
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]=Chanmv}

Checks if an object assigned to one of your AMAL channels is currently moving.

        test=Chanmv(channel number)

Gives a value of True (-1) it the object is moving, and False if it 
has stopped.
CHANNEL
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]=Channel}

Assigns  an  animation  channel  to anobject  type.   Allowable object types
include sprites, bobs, screens or rainbows!

        Channel channelnumber To Sprite s

Nominates an AMAL  channel to sprite number s.

        Channel channelnumber To Bob b

Appoints an AMAL channel to Bob b

        Channel channelnumber To Screen Display d

Moves the position of screen d using an AMAL channel. These screens CAN'T be
animated using Anim or the A register. They can only be repositioned.

        Channel channelnumber To Screen Offset h

Installs  the channel for use with Hardware Scrolling.  Screen h can now be
scrolled  directly  using  the  X  and  Y registers, or using the AMAL Move
command.

        Channel channelnumber to Screen Size z

Sets up your AMAL channel to change the size of your chosen AMOS screen.

        Channel channelnumber To Rainbow r

Scrolls a rainbow created using SET RAINBOW from inside an AMAL program.  X
holds the number of the first colour in the table to be displayed, Y stores
the position of the rainbow on the screen, and A contains the height.

MOVE FREEZE
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Move Freeze}

Temporarily  halts a STOS compatible MOVE command in its tracks.  It can be
restarted again with MOVE ON.

        Move Freeze

Freezes ALL movements.

        Move Freeze channel number

Stops just a single movement sequence.
MOVE OFF
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Move Off}

Permanently  erases a STOS compatible movement sequence created with MOVE X
or MOVE Y.

        Move Off

Kills ALL movements.

        Move Off Channel

Terminates just a single movement.
MOVE ON
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]Move On}

Starts  a  movement  sequence  created using the STOS compatible MOVE X and
MOVE Y instructions.

        Move On

Activates ALL movements.

        Move On Channel

Fires off a single channel.
MOVON
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]=Movon}

Checks  if  a  STOS  compatible  movement  sequence  is still active on the
selected  channel  number.  You'll get a value of True (-1) if the object`s
still moving, and a zero if it's finished.

        x=Movon(channel number)
MOVE X
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]=Move X}

Move  an  object horizontally using a STOS compatible command sequence.  As
with AMAL, the object is chosen with the CHANNEL command.

        Move X channel number,"(speed,step,count)..."

speed sets the delay in fiftieths of a second between the operations.

step enters the distance to be moved in each step.

count  specifies  the  number  of  steps which should be performed in every
operation.

You can also include the L or E directives at the end of your commands.

L

Loops the sequence continuously on the screen.

E x coord

Stops the sequence when the chosen coordinate value is reached.
MOVE Y
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_5.AMOS,0,4]=Move Y}

Move  an  object  vertically  using a STOS compatible command sequence.  As
with AMAL, the object is chosen with the CHANNEL command.

        Move Y channelnumber,"(speed,step,count)..."

speed sets the delay in fiftieths of a second between the operations.

step enters the distance to be moved in each step.

count  specifies  the  number  of  steps which should be performed in every
operation.

You can also include the L or E directives at the end of your commands.

L

Loops the sequence continuously on the screen.

E y coord

Stops the sequence when the chosen coordinate value is reached.

SYNCHRO
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_6.AMOS,0,4]Synchro}

Performs  all  your  AMAL programs in a single large burst.  It's used with
SYNCHRO  OFF  to allow you to control up to 63 objects at a time.  For best
results, add a WAIT VBL command at the end.

        Synchro
        Wait Vbl
SYNCHRO OFF 

{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_6.AMOS,0,4]Synchro Off}

Turns  off  the  automatic  AMAL movement system.  You can now execute your
AMAL programs directly at the most appropriate point in your program, using
the SYNCHRO command.

        Synchro Off

Note:   SYNCHRO  OFF  increases  the number of available animation channels
from 16 to 63, and lets you call up the =C,=SC,=BC functions from AMAL for
use with collision detection.

SYNCHRO ON
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_6.AMOS,0,4]Synchro On}

Restarts  the interrupt driven AMAL movement system, and executes your AMAL
programs in the background, fifty times a second.

        Synchro On
UPDATE EVERY
{[RAMOSPro_Tutorial:Tutorials/Amal/Amal_4.AMOS,0,4]Update Every}

Slows  down  the  object  movements  to provide plenty of time for even the
largest object to be displayed on the screen.

        Update Every delay

delay is the number of vertical blanks (VBL's) between each screen update.

Icons and Blocks

                   {[IDEL BLOCK       ,4,3] Del Block         } {[IICON BASE       ,4,3] =Icon Base        }
                   {[IDEL CBLOCK      ,4,3] Del Cblock        } {[IINS ICON        ,4,3] Ins Icon          }
                   {[IDEL ICON        ,4,3] Del Icon          } {[IMAKE ICON MASK  ,4,3] Make Icon Mask    }
                   {[IGET BLOCK       ,4,3] Get Block         } {[INO ICON MASK    ,4,3] No Icon Mask      }
                   {[IGET CBLOCK      ,4,3] Get Cblock        } {[IPASTE ICON      ,4,3] Paste Icon        }
                   {[IGET ICON        ,4,3] Get Icon          } {[IPUT BLOCK       ,4,3] Put Block         }
                   {[IGET ICON PALETTE,4,3] Get Icon Palette  } {[IPUT CBLOCK      ,4,3] Put Cblock        }
                   {[IHREV BLOCK      ,4,3] Hrev Block        } {[IVREV BLOCK      ,4,3] Vrev Block        }

DEL BLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Del Block}

DELetes one or more screen BLOCKs from memory.

        Del Block

Kills off ALL blocks.

        Del Block n

Erases block number n.
DEL CBLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Del Cblock}

DELetes one or more compressed screen BLOCKs from memory.

        Del Cblock

Kills off ALL compressed blocks.

        Del Cblock n

Erases compressed block number n.
DEL ICON
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Del Icon}

Deletes one or more icon images from the Icon Bank (bank 2).

        Del icon n

Erases Image number n

        Del Icon n To m

Wipes all images from n to m.
GET BLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Get Block}

Grabs a rectangular screen BLOCK from the screen, and saves it into memory.
An  optional  blitter  mask  can  be  created for your block as well.  This
ensures  that  colour zero will be treated as transparent when the block is
pasted onto the screen.

        Get Block n,x,y,width,height

Gets a block with number n from x,y to x+w,y+h on the current screen.

        Get Block n,x,y,width,height,mask

If mask=1 then a mask will be generated for your block. 
GET CBLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Get CBlock}

Gets  a rectangular screen BLOCK from the screen, and compresses it as much
as possible as it's being saved into memory.

        Get Cblock n,x,y,width,height

Grabs  a  block  with  number  n from x,y to x+w,y+h on the current screen.
Note that x and w are automatically rounded down to the nearest multiple of
eight.

GET ICON
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Get Icon}

Loads  an  icon  image  from  the screen, and saves it into the Icon bank.
(Bank 2)

        Get Icon i,tx,ty To bx,by

Grabs image number i from tx,ty to bx,by on the current screen.

        Get Icon s,i,tx,ty To bx,by

Gets an icon of the requested dimensions from screen s.
GET ICON PALETTE
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Get Icon Palette}

        Get Icon Palette

Loads all of your Icon colours to the current screen. 

An optional mask can be used to load a selection of these colours at a time.


        Get Icon Palette,mask

HREV BLOCK
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]Hrev Block}

Switches a block from left to right, just like a mirror.

        Hrev Block block number

ICON BASE
{[RAMOSPro_Examples:Examples/H-6/Help_64.AMOS,0,4]=Icon Base}

Returns the address of the Icon structure in memory.

        address=Icon Base
INS ICON
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Ins Icon}

        Ins Icon n

Inserts  a  blank  image  at  position n in the current icon bank.  All the
images after this number are moved down a place.

Ins Icon f To l

Creates several image slots in a single operation. 

A  series  of  blank  spaces will now be created between image number f and
image l.

MAKE ICON MASK
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Make Icon Mask}

Sets colour zero to transparent on selected images from the Icon bank.

        Make Icon Mask

Affects all currently defined Icon images.

        Make Icon Mask i

Creates a blitter mask for image number i. 
NO ICON MASK
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]No Icon Mask}

Removes  one  or  more Icon Masks which you've previously created using the
MAKE ICON MASK command.

        No Icon Mask

Removes all currently defined Icon masks.

        No Icon Mask i

Removes the mask for icon i.
PASTE ICON
{[RAMOSPro_Examples:Examples/H-6/Help_65.AMOS,0,4]Paste Icon}

Pastes an image from the Icon bank (2) onto the current screen.

        Paste Icon x,y,image number
PUT BLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Put Block}

Draws  a previously defined memory block on the screen.  If the coordinates
are ommitted, it will be replaced at it's original position.

        Put Block n
        Put Block n,x,y

There  are  also a couple of extended versions of this command for advanced
users.

        Put Block n,x,y,planes

Puts a block on the selected screen planes. 

planes is a bitmap containing a list of planes to be affected.

        Put Block n,x,y,planes,minterms

Puts  a  block  on  the selected screen planes using a writing mode entered
using in minterms.  See SET BOB for more info.

PUT CBLOCK
{[RAMOSPro_Examples:Examples/H-6/Help_66.AMOS,0,4]Put Cblock}

Redraws a compressed memory block on the screen.

If  the  coordinates  are  ommitted,  it  will be replaced at it's original
position.

        Put Cblock n
        Put Cblock,x,y
VREV BLOCK
{[RAMOSPro_Examples:Examples/H-2/Help_29.AMOS,0,4]Vrev Block}

Flips a BLOCK of graphics upside down.

        Vrev Block number

Sound Effects
                      {[IBELL     ,4,3] Bell          } {[IPLAY OFF ,4,3] Play Off      }
                      {[IBOOM     ,4,3] Boom          } {[ISAMPLE   ,4,3] Sample        }
                      {[IDEL WAVE ,4,3] Del Wave      } {[ISET ENVEL,4,3] Set Envel     }
                      {[ILED ON   ,4,3] Led On        } {[ISET WAVE ,4,3] Set Wave      }
                      {[ILED OFF  ,4,3] Led Off       } {[ISHOOT    ,4,3] Shoot         }
                      {[INOISE TO ,4,3] Noise To      } {[IVOLUME   ,4,3] Volume        }
                      {[IPLAY     ,4,3] Play          } {[IWAVE     ,4,3] Wave          }
BELL
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Bell}

Rings  a  bell.  It plays pure tone from a low pitch of 1 up to a very high
pitch of 96.

        Bell
        Bell pitchvalue
BOOM
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Boom}

Generates an explosive sound effect.

        Boom
DEL WAVE
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Del Wave}

DELetes  any  numbered  sound  WAVE,  except  0 and 1 which are permanently
programmed.

        Del Wave number
NOISE TO
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Noise To}

Assigns white NOISE TO a voice of your choice.

        Noise To voicenumber
LED ON
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Led On}

Activates a high frequency sound filter and turns on the power Light on the
computer.

        Led On
LED OFF
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Led Off}

Switches off the sound filter, and blanks out the power LED.

       Led Off
PLAY
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Play}

PLAYs  a note or waveform with your selected pitch and delay.  You can also
enter an optional combination of voices.

        Play voice
        Play voice,delay
        Play voice,pitch,delay
PLAY OFF
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Play Off}

Stops  a  note  or waveform previously set in action by a PLAY command.  An
optional voice or voices may be included.

        Play Off
        Play Off voices
SAMPLE
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Sample}

Assigns  a  SAMPLE  to  the  current  sound  wave.   The range of voices is
selected using a standard bit-map.

        Sample number To voices
SET ENVEL
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Set Envel}

Defines a sound ENVELope.

Set Envel wave,phase To duration,volume

wave = the number of the waveform,

phase = a phase number from 1 to 6

duration = length of the current step in units of a 50th of a second.

volume  =  the  intensity  of  the note at the end of the phase.  Allowable
values range from 0 to 63.

SET WAVE
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Set Wave}

Selects  a  WAVEform for your sound.  Waves 0 and 1 are permanently set up.
So  start  new  wave numbers from 2 upwards.  You can then set the shape of
the waveform from a list of 256 sample values in shape$.

        Set Wave number,shape$
SHOOT
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Shoot}

Triggers a SHOOTing sound. Great for your missiles!

        Shoot
VOLUME
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Volume}

Changes the VOLUME of all future effects. 

intensity  ranges  from  0  (silent)  up to 63 (very loud).  You can select
which voices are to be affected by setting their individual bits to 1.

        Volume intensity 
        Volume voices,intensity
WAVE
{[RAMOSPro_Examples:Examples/H-7/Help_76.AMOS,0,4]Wave}

Assigns  the wave number you select to one or more sound channels.  Set the
bit of any voices you wish to use to 1.

       Wave number To voices

Music
                        {[IMUSIC     ,4,3] Music                        }
                        {[IMUSIC OFF ,4,3] Music Off                    }
                        {[IMUSIC STOP,4,3] Music Stop                   }
                        {[IMVOLUME   ,4,3] Mvolume                      }
                        {[ITEMPO     ,4,3] Tempo                        }
                        {[IVOICE     ,4,3] Voice                        }
                        {[IVUMETER   ,4,3] Vumeter                      }
MUSIC
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Music}

Starts playing a piece of MUSIC from the music bank (3).

        Music number
MUSIC OFF
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Music Off}

Switches OFF all the current MUSIC.

        Music Off
MUSIC STOP
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Music Stop}

STOPS  the  current  piece  of  MUSIC and starts up any other music that is
still active.

        Music Stop
MVOLUME
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Mvolume}

Sets  the Music VOLUME by giving it a number from 0 for silent up to 63 for
very loud.

        Mvolume number
TEMPO   
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Tempo}

Changes the speed or TEMPO of a current piece of music, from 1 (lentissimo)
to 100 (presto furioso.)

        Tempo speed
VOICE
{[RAMOSPro_Examples:Examples/H-7/Help_75.AMOS,0,4]Voice}

Selects  one or more voices ready to perform, by setting its individual bit
mask to 1.

        Voice bitmap

        Voice %1111 : Rem Activate all four voices

Four  voices  can be used to play your sound.  Each voice to be played must
have its associated bit set to 1.

Bit0-> Voice 0
Bit1-> Voice 1
Bit2-> Voice 2
Bit3-> Voice 3

VUMETER
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]=Vumeter}

Returns  the  volume of current note in your music.  v selects the voice to
be tested.

        vol=Vumeter(voice)

Samples
                         {[ISAM BANK    ,4,3] Sam Bank                   }
                         {[ISAM LOOP ON ,4,3] Sam Loop On                }
                         {[ISAM LOOP OFF,4,3] Sam Loop Off               }
                         {[ISLOAD       ,4,3] Sload                      }
                         {[ISAM PLAY    ,4,3] Sam Play                   }
                         {[ISAM RAW     ,4,3] Sam Raw                    }
                         {[ISSAVE       ,4,3] Ssave                      }
                         {[ISAMSTOP     ,4,3] Sam Stop                   }
                         {[ISAMSWAP     ,4,3] Sam Swap                   }
                         {[ISAM SWAPPED ,4,3] =Sam Swapped               }

SAM BANK
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Bank}

Assigns a new numbered SAMple memory BANK for use in your program.

        Sam Bank number
SLOAD
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sload}

Loads part of a sample file into memory.

        Sload File_Number,Length To Address

File_Number  is the number of a file you've opened previously with the OPEN
IN File_Number,"Name" instruction.

Length  is  the number of bytes to load.  If this number is bigger than the
actual size of the file, then only the remaining bytes will be loaded.

Address is the destination address.

Your data is loaded from the current file postion, as set by POF.
SAM LOOP OFF
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Loop Off}

Disables the looping system generated by the SAM LOOP ON instruction

        Sam Loop Off
SAM LOOP ON
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Loop On}

Enables   sample  looping.   All  future  samples  will  now  be  repeated
continuously through your loudspeaker.

        Sam Loop On
SAM PLAY
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Play}

PLAYs the numbered sound SAMple through your loudspeaker.

        Sam Play sample_number

You can also extend this command like so:

        Sam Play voice_bitmap,sample_number

Each voice to be played is selected by setting its bit in the map to 1

        Sam Play voice_bitmap,sample_number,frequency

frequency  sets  the playback speed in samples per second.  Sensible values
range from 4000 for noises to 10000 for speech and music.
SAM RAW
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Raw}

Plays  a  sound SAMple from anywhere in memory.  Each voice to be played is
set  by  a  standard bit-pattern.  The address of the sample is then given,
followed  by  the  length of the sample to be played, then its frequency in
samples per second.

        Sam Raw voice,address,length,frequency
SAM STOP
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Stop}

Stops  a  sound  SAMple  previously set by a SAM PLAY command.  An optional
voice or voices may be given.

        Sam Stop voices

SAM SWAP
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]Sam Swap}

Initialises double buffered sample playing.  The actual swapping will only
occur when the sample has been totally played through the speaker.

        Sam Swap Voices To address,length

voice  is  a  bit pattern to define the voices to be affected,just like the
SAM RAW instruction.

address  is  the  address of the next section of your sample to play.  This
must be in chip memory.

length is the number of bytes to be played.

SAM SWAPPED
{[RAMOSPro_Examples:Examples/H-7/Help_74.AMOS,0,4]=Sam Swapped}

Returns  TRUE (-1) if the sample swapping has occurred, and the new buffer
you have initialised with the SAM SWAP instruction is being played through
your loudspeaker. Otherwise you'll get a value of FALSE (0).

        test=Sam Swapped(voice_number)

voice_number is the number of the voice you want to check (0 to 3).

SSAVE
Saves a section of memory at a specific point in a file.

        Ssave channelnumber, startaddress to endaddress

Channel  number  is  the number of a file you've opened previously with the
OPEN IN File_Number,"Name" instruction.

startaddress is the address of the first byte to be transferred.

endaddress is the address of the final one.

The  data  is saved starting from the current file position, as returned by
the POF function.

Tracker
                         {[ITRACK LOAD    ,4,3] Track Load                }
                         {[ITRACK LOOP ON ,4,3] Track Loop On             }
                         {[ITRACK LOOP OFF,4,3] Track Loop Of             }
                         {[ITRACK PLAY    ,4,3] Track Play                }
                         {[ITRACK STOP    ,4,3] Track Stop                }

TRACK LOAD
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Track Load}

Loads  a  Tracker  sound module into the memory bank number of your choice,
erasing  any existing data in this bank number before loading the new data.
The new bank will be called "Tracker".

Bank number 6 is used as a default.

Normal  AMOS  Professional  sound commands should NOT be used while Tracker
music is being played.

        Track Load "modulename",banknumber
TRACK LOOP ON
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Track Loop On}

Causes the current Tracker module to loop.

       Track Loop On

TRACK LOOP OF
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Track Loop Of}

Turns off a looping Tracker module.

       Track Loop Of
TRACK PLAY
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Track Play}

Starts your Tracker music playing through your loudspeaker.

        Track Play banknumber

bank  number  is  the  number  of  the  memory bank containing your tracker
module.  If it's omitted AMOS defaults to bank 6.

        Track Play, banknumber,patternnumber

A  pattern  number  can  also  be  added as a starting point from which the
Tracker module is to be played.

TRACK STOP
{[RAMOSPro_Examples:Examples/H-7/Help_72.AMOS,0,4]Track Stop}

Stops your music in its tracks!

        Track Stop

Med
                        {[IMED CONT   ,4,3] Med Cont                    }
                        {[IMED LOAD   ,4,3] Med Load                    }
                        {[IMED MIDI ON,4,3] Med Midi On                 }
                        {[IMED PLAY   ,4,3] Med Play                    }
                        {[IMED STOP   ,4,3] Med Stop                    }
MED CONT
{[RAMOSPro_Examples:Examples/H-8/Help_80.AMOS,0,4]Med Cont}

Re-starts  a  song  you've  previously halted with MED STOP.  The music now
continues from the point it left off.

       Med Cont

MED LOAD
{[RAMOSPro_Examples:Examples/H-8/Help_80.AMOS,0,4]Med Load}


Loads a selected MED music module into a selected memory bank.  Only "MMD0"
and "MMD1" type modules are allowed.

       Med Load "Med_Module",bank
MED MIDI ON
{[RAMOSPro_Examples:Examples/H-8/Help_80.AMOS,0,4]Med Midi On}

This  instruction  should be used if you've connected a MIDI synthesizer to
your  Amiga,  and wish to play a MED module containing MIDI commands.  Call
it before the MED ON command.

         Med Midi On

MED STOP
{[RAMOSPro_Examples:Examples/H-8/Help_80.AMOS,0,4]Med Stop}

Stops  the MED music currently being played through your loudspeaker.  This
song can be re-started again using the MED CONT instruction.

        Med Stop
MED PLAY
{[RAMOSPro_Examples:Examples/H-8/Help_80.AMOS,0,4]Med Play}

Plays  a  MED  music module which has been previously loaded with MED LOAD.
If  you  don't include a parameter, the most recently loaded module will be
played instead.

        Med play

If  you've  several  modules  installed  in  memory, you can enter the bank
number like so:

       Med Play bank

You can also specify a song number if required.

       Med Play bank,song


The Keyboard
                        {[ICLEAR KEY  ,4,3] Clear Key                    }
                        {[IINKEY$    ,4,3] =Inkey$                      }
                        {[IINPUT$    ,4,3] =Input$                      }
                        {[IINPUT      ,4,3] Input                        }
                        {[IKEY$=     ,4,3] =Key$=                       }
                        {[IKEY STATE ,4,3] =Key State                   }
                        {[IKEY SHIFT ,4,3] =Key Shift                   }
                        {[IKEY SPEED  ,4,3] Key Speed                    }
                        {[ILINE INPUT ,4,3] Line Input                   }
                        {[IPUT KEY    ,4,3] Put Key                      }
                        {[ISCAN$     ,4,3] =Scan$                       }
                        {[ISCANCODE   ,4,3] =Scancode                    }
                        {[ISCANSHIFT  ,4,3] =Scanshift                   }
                        {[IWAIT KEY   ,4,3] Wait Key                     }

CLEAR KEY
{[RAMOSPro_Examples:Examples/H-4/Help_42.AMOS,0,4]Clear Key}

Clears  any  keypresses from the keyboard buffer, leaving it totally empty.
Any earlier keypresses will be discarded.

        Clear Key
INKEY$
{[RAMOSPro_Examples:Examples/H-4/Help_43.AMOS,0,4]=Inkey$}

Checks  to  see if you have pressed a particular KEY, and returns its value
in a String.

        x$=Inkey$ : If x$<>" " Then Print x$
KEY$
{[RAMOSPro_Examples:Examples/H-5/Help_54.AMOS,0,4]Key$}

Assigns  or  reads a keyboard macro.  These macros can be accessed from the
keyboard  by  pressing  the  Amiga  key  along with one of the ten possible
function keys.

Left Amiga generates macros from 1-10 depending on the function key.

Right Amiga reads macros from 11 to 20.

        Key$(m)="string"

Defines  your  macro.   "string"  now  will be automatically typed into the
keyboard when you call up macro m.

        s$=Key$(m)

Reads the current macro assigned to function m.  
KEY SPEED
{[RAMOSPro_Examples:Examples/H-4/Help_42.AMOS,0,4]Key Speed}

Changes the SPEED of KEYboard action.  Lag is the time in 50ths of a second
before  characters  are  repeated  while  a key is held down.  Speed is the
delay in 50ths of a second between each successive character.

        Key Speed lag,speed
KEY STATE
{[RAMOSPro_Examples:Examples/H-4/Help_43.AMOS,0,4]=Key State}

Tests a specific key to see if it has been pressed by the user.  A value of
-1 indicates that the key has been hit.

        Test=Keystate(scancode)
        If Key State(69) Then Print "Escape pressed"

KEYSHIFT
{[RAMOSPro_Examples:Examples/H-4/Help_43.AMOS,0,4]=Key Shift}

Returns the status of special keys such as CNTRL,SHIFT,and ALT.  The result
is given as a bit-map in the following format.

        keys=Key Shift

Bit    Key Tested
 0     Left Shift
 1     Right Shift
 2     Caps Lock
 3     Cntrl
 4     Left Alt
 5     Right Alt
 6     Left Amiga
 7     Right Amiga
LINE INPUT
{[RAMOSPro_Examples:Examples/H-6/Help_63.AMOS,0,4]Line Input}

INPUTs  a  list  of  variables one at a time, separated by the [Return] key
instead of the comma used in the normal INPUT command.

        Line Input "Prompt";variable list
PUT KEY
{[RAMOSPro_Examples:Examples/H-4/Help_42.AMOS,0,4]Put Key}

Loads  a  string  of  characters  directly  into the keyboard buffer.  AMOS
treats these characters just as if they had been typed in straight from the
keyboard.

        Put Key "characters"
SCAN$
{[RAMOSPro_Examples:Examples/H-5/Help_54.AMOS,0,4]=Scan$}

Returns an internal code for use with the keyboard macros defined with KEY$.

        c$=Scan$(n)

Generates the code for scancode n.

        c$=Scan$(n,m)

m  enters  an optional mask for the special keys such as ALT or SHIFT.  See
SHIFT KEY for more details.

SCANCODE
{[RAMOSPro_Examples:Examples/H-4/Help_43.AMOS,0,4]=Scancode}

Returns  the  SCANCODE of the last key-press recognised by INKEY$.  As well
as  character  keys,  this function can also check for keys like [Help] and
[Tab].

        s=Scancode

SCANSHIFT
Returns  the status of the shift keys after you`ve tested the keyboard with
INKEY$. 

        s=Scanshift

Depending on the situation, you`ll get one of the following values.

          =0      no [Shift]
          =1      [Left Shift]
          =2      [Right Shift]
          =3      both [Shift] keys set

WAIT KEY
{[RAMOSPro_Examples:Examples/H-4/Help_42.AMOS,0,4]Wait Key}

WAITs for any single KEY to be pressed.

        Wait Key


Serial Communications
                {[ISERIAL ABORT   ,4,3] =Serial Abort        } {[ISERIAL CLOSE    ,4,3] Serial Close         }
                {[ISERIAL BASE    ,4,3] =Serial Base         } {[ISERIAL FAST     ,4,3] Serial Fast          }
                {[ISERIAL CHECK   ,4,3] =Serial Check        } {[ISERIAL OPEN     ,4,3] Serial Open          }
                {[ISERIAL ERROR   ,4,3] =Serial Error        } {[ISERIAL OUT      ,4,3] Serial Out           }
                {[ISERIAL GET     ,4,3] =Serial Get          } {[ISERIAL PARITY   ,4,3] Serial Parity        }
                {[ISERIAL INPUT$  ,4,3] =Serial Input$       } {[ISERIAL SEND     ,4,3] Serial Send          }
                {[ISERIAL STATUS  ,4,3] =Serial Status       } {[ISERIAL SLOW     ,4,3] Serial Slow          }
                {[ISERIAL BITS     ,4,3] Serial  Bits         } {[ISERIAL SPEED    ,4,3] Serial Speed         }
                {[ISERIAL BUF      ,4,3] Serial  Buf          } {[ISERIAL X        ,4,3] Serial X             }

SERIAL ABORT

Winds  up  any  serial  operations  you've  started with the SERIAL SEND or
SERIAL OUT instructions and leaves the lines clear.


        Serial Abort channel_no
SERIAL BASE
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]=Serial Base}

Returns the base  address of the IO structure of the current serial channel.

        address=SERIAL BASE(channel_no)
SERIAL BITS
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Bits}

Assigns  the  number  of  bits  which  will  be used for each character you
transmit.

        Serial Bits channel_no,nbits,stopbits

channel holds the chaneel number

nbits is the number of bits

stopbits is the number of STOP bits
SERIAL BUF
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Buf}

Allocates  the  amount  of buffer space to be used for your for your serial
channel.   Note  that  the  default  value  is  512  bytes  and the minimum
allocation  is  64 bytes.  It's a good idea to increase the buffer size for
high speed transfers.

        Serial Buf channel_no, Length
SERIAL CHECK
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]=Serial Check}

Asks  the  device  for a read-out of its current status.  You can use it to
check whether all the information you've transferred with a previous SERIAL
SEND command has been correctly sent.

        test=Serial Check(channel)

test = FALSE (0) -> the last serial command is still being executed.
     = TRUE (-1) -> All done!
SERIAL CLOSE
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]Serial Close}

Close one or more serial channels.

        Serial Close

Closes ALL active channels

        Serial Close channel

Closes a single channel
SERIAL ERROR
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Error}

Looks  for  the ERROR byte in the serial device.  A value of zero indicates
that everything is fine.  Otherwise, the last transmission was faulty.

        test=Serial Error(channel)

SERIAL FAST
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]Serial Fast}

Sets  a  special  fast  flag  in  the  current device and disables a lot of
internal  checking  which  would  otherwise  slow  down  the  communication
process.  Use it for high speed transfers such as MIDI.  Warning:  When you
call  this  command,  the  protocol  will  be  changed  to:  

PARITY EVEN,NOXON/XOFF and 8 bits.

        Serial Fast channel
SERIAL GET
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]=Serial Get}

Reads  a  single  byte  from  the serial device.  If nothing is available a
value of -1 will be returned.

        v=Serial Get(channel)
SERIAL INPUT$
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]=Serial Input$}

Reads  an  entire string of characters from the serial port.  If there's no
data,  the  command  will  return an empty string "".  Otherwise the string
will  contain all the bytes which have been sent over the serial line up to
the present time.

        s$=Serial Input$(channel)
SERIAL OPEN
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]Serial Open}

Opens a communication channel to a serial device.

Serial Open channel, port_no

channel holds the channel number from 0 to 3.

port_no  specifies the logical device number of the serial port.  Normally,
it should be set to zero.

If  you  need  additiona control over the serial port, you can also call an
extended version of this instruction.

Serial Open channel, port_no,shared, xdisabled, 7wires
SERIAL OUT
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]Serial out}

Transmits  a  block  of  memory  over  the  serial  port  using the current
settings.

Serial Out channel,address,length

Address is the address of your data in memory.

Length is the number of bytes to be transmitted.
SERIAL PARITY
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Parity}

Sets the parity checking you are using for the current serial channel.

        Serial Parity channel, parity

Here's a list of the available options.

   -1 : no parity
    0 : EVEN parity
    1 : ODD parity
    2 : SPACE parity
    3 : MARK parity

See the Commodore documentation for a full explanation of this system.
SERIAL SEND
{[RAMOSPro_Examples:Examples/H-4/Help_46.AMOS,0,4]Serial Send}

Sends  a string of characters straight to the specified serial channel.  It
doesn't  wait  for  the  data  to  be  transmitted through the actual port.
You'll  therefore need to use the =SERIAL CHECK(Channel) function to detect
when the transmission has been successfully completed.

Serial Send channel,t$ 
SERIAL SLOW
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Slow}

Slows  the serial device back to normal speed and reactivates all the error
checks.

        Serial Slow channel

SERIAL SPEED
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial Speed}

Sets  the current transfer rate of the appropriate channel.  The same value
will  be used for both reading and writing operations.  You can't set split
baud rates for a single channel.

If the baud rate you have specified is not supported by the current device,
it may be rejected.

        Serial Speed channel, baud rate

SERIAL STATUS
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]=Serial Status}

Provides  you  with  detailed  information  about  the current state of the
serial port.

        s=Serial Status(channel)

s is a bit-map holding the state of fifteen different parameters.  

If  the  bit  is  set to the value under "active", the associated event has
been successfully detected.

Bit Active Function

 0-1   -   reserved
 2     1   Parallel "select" on the A1000
 3     0   DSR (Data Set Ready)
 4     0   CTS (Clear To Send)
 5     0   Carrier Detect
 6     0   RTS (Ready To Send)
 7     0   DTR (Data Terminal Ready)
 8     1   hardware overrun
 9     1   break sent (most recent output)
10     1   break received (as latest input)
11     1   transmit x-OFF
12     1   receive x-OFF
13-15  -   reserved 
SERIAL X
{[RAMOSPro_Examples:Examples/H-4/Help_47.AMOS,0,4]Serial X}

Activates/deactivates the XON/XOFF handshaking system. 

        Serial X channel,xmode 

A  value  of TRUE for Xmode disables handshaking.  Any other value turns it
on.   Xmode  should  be  loaded with the correct control characters.  These
must be specified in the following format:

        Xmode=XON*$10000000+XOFF*$10000

Check Commodore's documentation for more information.

Using the Printer
                          {[ILPRINT        ,4,3] Lprint                   }
                          {[IPRINTER ABORT ,4,3] Printer Abort            }
                          {[IPRINTER BASE  ,4,3] Printer Base             }
                          {[IPRINTER CHECK ,4,3] Printer Check            }
                          {[IPRINTER CLOSE ,4,3] Printer Close            }
                          {[IPRINTER DUMP  ,4,3] Printer Dump             }
                          {[IPRINTER ERROR ,4,3] Printer Error            }
                          {[IPRINTER ONLINE,4,3] Printer Online           }
                          {[IPRINTER OPEN  ,4,3] Printer Open             }
                          {[IPRINTER OUT   ,4,3] Printer Out              }
                          {[IPRINTER SEND  ,4,3] Printer Send             }
LPRINT
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]Lprint}

Sends a List of variables to a PRINTer instead of the screen.

        Lprint variable list
PRINTER ABORT
{RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Abort}

Halts  a  printing operation in it's tracks.  If your printer's got a large
memory  buffer,  you  may need to wait a while before the printing actually
stops.  If in doubt, turn it off!

        Printer Abort
PRINTER BASE

{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]=Printer Base}

Returns the address of the IO structure used to control the printer.

        address=Printer Base

PRINTER CHECK
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]=Printer Check}

Returns  a  value  of  TRUE  (-1)  if  the printer is available for use, or
FALSE(0) if it's in the middle of an operation.

        c=Printer Check
PRINTER CLOSE
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Close}

Close  the  printer  port  you've  previously  set up with the PRINTER OPEN
command.

        Printer Close
PRINTER DUMP
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Dump}

PRINTER  DUMP  sends the current screen straight to the printer, just as it
appears on your TV set.

        Printer Dump

Dumps the entire screen in a single operation.

        Printer Dump x1,y1 to x2,y2

Transmits  a  selected  area  of  your screen to the printer, retaining the
present aspect ratio and the screen size.

x1,y1  hold the position of the top left corner of your image

x2,y2  set the location of the point diagonally opposite.

         Printer Dump x1,y1 to x2,y2,px,py,s

Prints  a  section  of  the  screen  using  your own aspect ratios and size
parameters.

x1,y1  define the top left corner of the area to be printed.

x2,y2  enter the coordinates of the bottom right of the image.

px,py  specify  the  dimensions  of  the  final printout.  These values are
measured  in  "printer pixels" rather than normal screen points.  They vary
depending on the command options you've set with s.

s  is  a special command parameter which tells the printer precisely how to
draw  your image onto the paper.  See the AMOS Pro User Guide for a list of
the various options.

PRINTER ERROR
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]=Printer Error}

Checks  whether  the  current operation is proceeding normally.  A value of
zero suggests that everything's ok.  Any other value indicates an error.

        e=Printer Error

PRINTER ONLINE
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]=Printer Online}

Checks  whether  your printer is connected and ready for use.  It returns a
value  of  TRUE  (-1)  if  the printer is online, and FALSE(0) if it is not
available.

        test=Printer Online
PRINTER OPEN 
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Open}

Opens  the  printer  device  using your current preferences.  Only a single
printer  device  can  be  open  at  any  one  time.  So we haven't bothered
including a channel number.

        Printer Open
PRINTER OUT
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Out}

Prints  some  data  directly from the memory locations starting at address.
This  data  is not processed in any way, and any embedded control sequences
are totally ignored.  You should only use this instruction to send graphics
or simple text.

        Printer Out address, length

address is the address of the first character to be output.

length  holds the number of characters you wish to print. 
PRINTER SEND
{[RAMOSPro_Examples:Examples/H-5/Help_51.AMOS,0,4]Printer Send}

Sends a string to the printer using multitasking. 

The instruction returns immediately back to AMOS Basic, without waiting for
the  text to be actually printed.  Instead, all printing operations will be
performed invisibly in the background.  If the printer is not ready, you'll
get an appropriate requester.

        Printer Send a$

The Parallel Port
                          {[IPARALLEL BASE  ,4,3] =Parallel Base         }
                          {[IPARALLEL CHECK ,4,3] =Parallel Check        }
                          {[IPARALLEL ERROR ,4,3] =Parallel Error        }
                          {[IPARALLEL INPUT$,4,3] =Parallel Input$       }
                          {[IPARALLEL STATUS,4,3] =Parallel Status       }
                          {[IPARALLEL ABORT  ,4,3] Parallel Abort         }
                          {[IPARALLEL CLOSE  ,4,3] Parallel Close         }
                          {[IPARALLEL OPEN   ,4,3] Parallel Open          }
                          {[IPARALLEL OUT    ,4,3] Parallel Out           }
                          {[IPARALLEL SEND   ,4,3] Parallel Send          }

PARALLEL ABORT
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]Parallel Abort}

Stops  the  PARALLEL  SEND  or  PARALLEL OUT commands from transmitting any
additional  information  over  the parallel port.  Any characters which are
currently in transit will be completely lost.

        Parallel Abort
PARALLEL BASE
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]=Parallel Base}

Returns the address of the internal memory area used to handle the parallel
port.

        address=Parallel Base
PARALLEL CHECK
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]=Parallel Check}

Returns  a  value  of  TRUE  (-1) if the parallel port is ready for use, or
FALSE(0) if it's not available.

        c=Parallel CHECK
PARALLEL CLOSE
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]Parallel Close}

Closes the parallel port, and frees up any memory back to the system. 

        Parallel Close
PARALLEL ERROR
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]=Parallel Error}

Checks  for  an  error  in  the  current  transmission.  If it's proceeding
normally,  you get a value of zero.  Any other value indicates a problem of
some sort.

        e=Parallel Error
PARALLEL INPUT$
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]=Parallel Input$}

Waits for a specific number of characters from the parallel port.

        d=Parallel Input$(length)

Since  the parallel port doesn't have an internal buffer area, your program
will  halt  completely  until the characters are successfully received.  If
the  requested  bytes  haven't  arrived  after a reasonable amount of time,
you'll get a time-out error.

        d=Parallel Input$(length ,stop)

stop  enters  an  optional a stop character which will end the transmission
the moment it's recieved.

PARALLEL OPEN
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]Parallel Open}

Initialises the parallel port for use by your AMOS program.

        Parallel Open
PARALLEL OUT
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]Parallel Out}

Transmits  some  characters  through  the  parallel  port  starting  from a
specific memory address.

        Parallel Out address, length
PARALLEL SEND
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]Parallel Send}

Sends  a  string  to the parallel port using multitasking.  The instruction
returns  immediately back to AMOS Basic, without waiting for the text to be
actually transmitted.

        Parallel Send a$

PARALLEL STATUS
{[RAMOSPro_Examples:Examples/H-8/Help_81.AMOS,0,4]=Parallel Status}

Returns   information   about  the  parallel  port.   Each  possibility  is
represented by a single bit in the result.

        s=Parallel Status

Bit     Function
 0      Printer selected
 1      Paper out
 2      Printer busy
 3      Direction (read=0 / write=1)

Using the AmigaDos Libraries
                          {[IDOSCALL       ,4,3] =Doscall                }
                          {[IEQU           ,4,3] =Equ                    }
                          {[IEXECALL       ,4,3] =Execall                }
                          {[IGFXCALL       ,4,3] =Gfxcall                }
                          {[IINTCALL       ,4,3] =Intcall                }
                          {[ILIB BASE      ,4,3] =Lib Base               }
                          {[ILIB CALL      ,4,3] =Lib Call               }
                          {[ILVO           ,4,3] =Lvo                    }
                          {[ISTRUC=        ,4,3] =Struc=                 }
                          {[ILIB CLOSE      ,4,3] Lib Close               }
                          {[ILIB OPEN       ,4,3] Lib Open                }
                          {[ISET EQUATE BANK,4,3] Set Equate Bank         }
DOSCALL
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]=Doscall}

Calls a routine from the DOS library.

As  with  LIB  CALL, you'll first need to set up the control registers into
D0-D7 and A0-A3 using the AREG() and DREG() functions.

After  the  command  has  been executed, the return value will be available
from D0 as the result.

        result=Doscall(function_offset)

function_offset  enters  the  offset to the relevant library function.  The
offset  can  be  either a simple number, or a named function (using the LVO
command).

EXECALL
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]=Execall}

Calls the EXEC library with the selected offset value.

On  entry,  registers D0 to D7 and A0 to A2 MUST be loaded with the control
settings required by your function.  At the end, the contents of D0 will be
returned to AMOS Basic.

        result=Execall(function_offset)

GFXCALL
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]=Gfxcall}

Executes  your  chosen  function straight from the Graphics library, taking
the parameters from the DREG() and AREG() arrays.

function_offset enters the offset to the function you wish to call.  It can
also be set using the LVO function if required.

        result=Gfxcall(function_offset)
INTCALL
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]=Intcall}

Calls a command directly from the Intuition library. 

Before  using  this  function,  it's  vital to load the appropriate control
parameters  into  the  registers D0-D7 and A0-A3.  This can be accomplished
with the AREG() and DREG() variables from AMOS Basic.

When  the  function terminates, the contents of D0 will be returned back to
your program.

        result=Intcall(function_offset)
LIB BASE
Returns  the  base  address  of  the  selected  library.  It can be used in
conjunction  with  the  STRUC  command  to  manipulate  the  internal  data
structures directly.

        address=Lib Base(channel)
LIB CALL
Calls  your  chosen  library  command, and returns the result to your Basic
program.

function_offset  holds  the  offset  to  the  library  function you want to
execute.  It can be entered by name using the LVO function.

Before calling this function, you'll need to load the appropriate parameter
values  into  the  Address  and  Data  registers  with  AREG()  and DREG().
Similarly,  after  the  function has been successfully executed, any return
values will be available immediately from the AREG and DREG variables.

        result=Lib Call(channel,function_offset)
LIB CLOSE

Closes one or all of the currently open libraries

        Lib Close 

Closes ALL libraries in a single operation.

        Lib Close channel

Closes a single Amiga library
LIB OPEN

Calls  the OPEN LIBRARY function from EXEC.  If the library is external, it
will  be  loaded  into memory from the LIBS folder of your present start-up
disc.

        Lib Open channel,"name.library",version

version specifies the minimum version number of the library to be installed
into memory.  Use a value of zero if you're unsure.

SET EQUATE BANK

Allocates  a memory bank for use by the automatic equate system.  It should
be  called  up BEFORE the first equate in your program, preferably near the
beginning.

bank_number   is  the  number  of  a  memory  bank  to  be  used  for  your
equates,ranging from 1 to 65535.  Beware!  Any bank of the same number WILL
BE ERASED when the equates are installed in memory, WITHOUT warning!

        Set Equate Bank bank_number

LVO

Returns the Library Vector Offset associated with the selected function.

The  function  name  will  be translated automatically when your program is
first  tested,  and  placed in a memory bank for future use.  If it doesn't
exist, you'll get an "Equate not found error" from the Editor.

Before  using this function, you'll need to set up a memory bank with a SET
EQUATE BANK command.  Otherwise, you'll get an appropriate error message.

        offset=LVO("Name_of_the_function")

EQU

EQU returns any standard equate value used by the Amiga system libraries.

The  equate  can  represent  anything from the offset to a structure,to the
names  of  your various bit masks.  Providing it's supplied on the standard
Amiga include files, it will be immediately available from AMOS Basic.

The  only  exception  to this rule, are the library offsets.These should be
obtained with the =LVO() function.

It's  important  to  emphasise  that  the  name  string MUST be a constant.
Expressions are NOT allowed!

        equate=Equ("name_of_the_equate")

STRUC

STRUC provides you with a simple way of assigning a value to any one of the
elements of a system structure.

        value=Struc(address,"offset_name")

        Struc(address,"offset_name")=value

address  holds  the address of your structure in memory.  This will usually
be returned by either a LIB BASE or a DEV BASE function.

Offset_Name  is  the  name of the relevant data object from the appropriate
manual.

The  name  will  be converted into the offset number by AMOS Basic using
the powerful auto-equate system.  You'll therefore need to include a SET
EQUATE BANK  command  near  the  start of your program in order to
initialise this feature.

Devices

                        {[IDEV ABORT  ,4,3] Dev Abort                   }
                        {[IDEV BASE  ,4,3] =Dev Base                   }
                        {[IDEV CHECK ,4,3] =Dev Check                  }
                        {[IDEV CLOSE  ,4,3] Dev Close                   }
                        {[IDEV DO     ,4,3] Dev Do                      }
                        {[IDEV OPEN   ,4,3] Dev Open                    }
                        {[IDEV SEND   ,4,3] Dev Send                    }
                        {[IOPEN PORT ,4,3] =Open Port                  }
                        {[IPORT      ,4,3] =Port                       }

DEV ABORT

Executes an AbortIO and a WaitIO command to clear all pending action of the
specified  device.   You  can  use this instruction to exit directly from a
multitasking operation, without waiting for it to complete normally.

        Dev Abort channel
DEV BASE

Returns  the  base  address  of  the  IO  structure assigned to the current
device.   This  structure can now be manipulated directly using the STRUC()
instructions as required.

        address=Dev Base(channel)
DEV CHECK

Performs  a  CheckIO  on the specified channel, and passes the return value
back to AMOS Basic.

DEV CLOSE

Closes  one  or more opened devices, as initialised with DEV OPEN.  It then
returns  the  memory  used  by  the  IO  structure  back to AMOS Basic, and
releases the message port for subsequent use.

        Dev Close

Closes all devices

        Dev Close channel

Channel selects a single device to be shut down.
DEV DO

Executes a DOIO operation on the specified channel.

You  should  of course, set the proper internal parameters of the structure
using the STRUC() command before calling this option.

        Dev Do channel,command

channel is the number of a previously opened device channel

command  holds  the number the IO command you wish to DO.  This command can
be entered directly using it's name using the built in EQU function.

DEV OPEN

Opens  a  communication  port, and prepares the device for use by your AMOS
programs.    If   this   device  is  not  already  installed,  it  will  be
automatically loaded from the DEVS folder of your current start-up disc.

        Dev Open(channel,"name.device",iolength,unitnumber,flags)
DEV SEND

Calls  the  SendIO  command  from  Exec,  and runs your operation using the
Amiga's  built-in  multitasking  system.   Your  new  process  will now run
invisibly   in   the  background.   So  your  AMOS  program  will  continue
immediately from the next instruction.

        Dev Send channel,command

OPEN PORT
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]Open Port}

Provides  a  simple  way of accessing the various devices connected to your
Amiga.

        Open Port channel number,"PAR:"

For the Parallel port.

        Open Port channel number,"SER:"

For the RS232 (serial) port.

        Open Port  channel number,"PRT:"

For the Printer port.

Once  you've  opened  your  channel,  you  can  access  it using any of the
INPUT#,INPUT$,PRINT#  or  LINE  INPUT# commands, just as if it was a normal
disc channel.

PORT
{[RAMOSPro_Examples:Examples/H-6/Help_67.AMOS,0,4]Port}

Tests  a  port you've previous initialised with OPEN PORT, and sees if it's
waiting for you to read it.

        test=PORT(channel number)

You'll get a value of True (-1) if there's  some data ready, otherwise 
False (0).
Arexx

                        {[IAREXX      ,4,3] =Arexx                      }
                        {[IAREXX$     ,4,3] =Arexx$                     }
                        {[IAREXX ANSWER,4,3] Arexx Answer                }
                        {[IAREXX CLOSE ,4,3] Arexx Close                 }
                        {[IAREXX EXIST ,4,3] Arexx Exist                 }
                        {[IAREXX OPEN  ,4,3] Arexx Open                  }
                        {[IAREXX WAIT  ,4,3] Arexx Wait                  }
AREXX
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]=Arexx}

Performs   a  GET  MESSAGE  command  from  the  Amiga's  operating  system.
Depending on the result, you'll get one of the following values.

0   There's no message. Try again later.

1   A message has just arrived. But it doesn't need a response.

2   A message has been received. Please answer immediately with an
    appropriate return string.

        status=Arexx
AREXX$
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]=Arexx$}

After  a  message  has  been successfully received from an AREXX compatible
program, you can read it's contents with the AREXX$ function.

        message$=Arexx$(arg_number)

arg_number  is  the number of the argument you wish to read, ranging from 0
to 15.  If it's not included, you'll get an empty string "".

AREXX ANSWER
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]Arexx Answer}

Replies  to  a  message  passed  from another AREXX program running on your
Amiga.

        Arexx Answer error
        Arexx Answer error,return$
AREXX CLOSE
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]Arexx Close}

Closes a previously opened AREXX communications port.

        Arexx Close
AREXX EXIST
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]Arexx Exist}

Checks  for  the  presence  of  a  named  communication port in the Amiga's
memory.   You'll get a value of TRUE(-1) if it's available, and a FALSE (0)
if there's some sort of problem.

        test=Arexx Exist("PORT_NAME")
AREXX OPEN
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]Arexx Open}

Sets up an AREXX communication port ready for immediate use.

        Arexx Open "PORT_NAME"

AREXX WAIT
{[RAMOSPro_Examples:Examples/H-8/Help_84.AMOS,0,4]Arexx Wait}

Halts your AMOS program completely until a message arrives from one of your
concurrent programs.

        Arexx Wait

Memory Conservation

                         {[ICHIP FREE       ,4,3] =Chip Free             }
                         {[IFAST FREE       ,4,3] =Fast Free             }
                         {[ICLOSE EDITOR    ,4,3] Close Editor           }
                         {[ICLOSE WORKBENCH ,4,3] Close Workbench        }
                         {[IKILL EDITOR     ,4,3] Kill Editor            }
CLOSE EDITOR
{[RAMOSPro_Examples:Examples/H-5/Help_54.AMOS,0,4]Close Editor}

CLOSEs  the  EDITOR  window  while  your  program is running, saving 55k of
memory.

        Close Editor
CLOSE WORKBENCH
{[RAMOSPro_Examples:Examples/H-5/Help_54.AMOS,0,4]Close Workbench}

Closes  the  Workbench  and kills off any multi-tasking programs, saving at
least 40k of memory for your AMOS Basic programs.

        Close Workbench

CHIP FREE
{[RAMOSPro_Examples:Examples/H-6/Help_64.AMOS,0,4]=Chip Free}

Returns  the  amount  of FREE CHIP memory.  This memory can be used to hold
screens, objects and sound samples.

        Print Chip Free
FAST FREE
{[RAMOSPro_Examples:Examples/H-6/Help_64.AMOS,0,4]=Fast Free}

Returns  the  number of bytes of FAST memory FREE for use.  Fast memory can
be used for static items like variables and AMAL animation sequences.

        Print Fast Free
KILL EDITOR

Stores  the  programs  you  are  editing on the disc and removes the Editor
completely  from  memory,  saving  at least 40K of extra space!  The Editor
will  be  reloaded  after  your  program  has finished, along with all your
current program listings.

        Kill Editor


Fonts
                        {[IFONT$       ,4,3] =Font$                     }
                        {[ITEXTBASE    ,4,3] =Text Base                 }
                        {[ITEXTLENGTH  ,4,3] =Text Length               }
                        {[ITEXTSTYLES  ,4,3] =Text Styles               }
                        {[IGETDISCFONTS,4,3] Get Disc Fonts             }
                        {[IGETFONTS    ,4,3] Get Fonts                  }
                        {[IGETROMFONTS ,4,3] Get Rom Fonts              }
                        {[ISETFONT     ,4,3] Set Font                   }
                        {[ISETTEXT     ,4,3] Set Text                   }
                        {[ITEXT        ,4,3] Text                       }


FONT$
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]=Font$}

FONT$  returns details about the chosen text style.  The result is a string
of exactly 38 characters, in the following format.

1  - 29  Font name
30 - 33  Font height
34 - 37  Identifier (Rom or Disc)

        a$=Font$(font_number)

GET FONTS
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Get Fonts}

Creates  an  internal  list  of  all  available  text fonts.  These include
built-in  ROM  fonts,  and the DISC fonts on your start-up disc.  GET FONTS
should  be called once at the start of your program, before you select your
font  with  the SET TEXT command.  You can scan through the available fonts
using the FONT$ function.

        Get Fonts

GET DISC FONTS
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Get Disc Fonts}

Creates  an internal list of the fonts provided in the FONTS:  directory of
your  current start-up disc.  This command can be used as an alternative to
GET FONTS.

         Get Disc Fonts

If  you  want  to  read the fonts from another disc, use the ASSIGN command
like so:

         Assign "FONTS:" To "Df1:FONTS"
GET ROM FONTS
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Get Rom Fonts}

Generates an internal list of the Rom fonts provided by Amiga's Hardware. 

        Get Rom Fonts
SET FONT
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Set Font}

Selects  the  FONT  to  be used by the next TEXT command, and loads it into
memory  if  required.   Before using this command, you'll need to create an
internal font list with either GET FONTS, GET DISC FONTS or GET FONT FONTS.

        Set Font number
SET TEXT
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Set Text}

Selects the style of the current graphics font.

        Set Text stylenumber

Stylenumber is a bit-pattern with the format:

Bit 0 = underlined
Bit 1 = bold 
Bit 2 = italic.
TEXT
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]Text}

Prints some graphic TEXT at your chosen SCREEN coordinates.

        Text x,y,t$

Note:   t$  must  be  a string.  If you want to use a number you must first
convert it into a string with the STR$ function.

TEXT BASE
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]=Text Base}

Returns  the  position of the coordinate BASEline used by your present TEXT
font.  It's similar to the Hot Spot of a Sprite.

        b=Text Base
TEXT LENGTH
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]=Text Length}

Returns the LENGTH of a section of a graphic character string in pixels.

        w=Text Length(t$)
TEXT STYLES
{[RAMOSPro_Examples:Examples/H-7/Help_79.AMOS,0,4]=Text Styles}

Returns the current TEXT STYLES you've assigned with SET TEXT.

        s=Text Styles

Speech
                          {[IMOUTHHEIGHT,4,3] Mouth Height              }
                          {[IMOUTHREAD   ,4,3] Mouth Read                }
                          {[IMOUTHWIDTH ,4,3] =Mouth Width              }
                          {[ISAY         ,4,3] Say                       }
                          {[ISETTALK     ,4,3] Set Talk                  }
                          {[ITALKMISC    ,4,3] Talk Misc                 }
                          {[ITALKSTOP    ,4,3] Talk Stop                 }
MOUTH WIDTH
{[RAMOSPro_Examples:Examples/H-8/Help_83.AMOS,0,4]=Mouth Width}

Returns  the  current  width  of  the "mouth" used to generate your speech.
You'll get a NEGATIVE value if the speech is over.

        Print Mouth Width

MOUTH HEIGHT
{[RAMOSPro_Examples:Examples/H-8/Help_83.AMOS,0,4]=Mouth Height}

Returns  the  height of the imaginary mouth used to create your speech at a
given instant.  You'll get get a NEGATIVE value if the speech has finished.

        Print Mouth Height

MOUTH READ
{[RAMOSPro_Examples:Examples/H-8/Help_83.AMOS,0,4]Mouth Read}

Waits for a movement of the mouth, and reads the new position directly into
=MOUTH WIDTH and =MOUTH HEIGHT.

SAY
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Say}

SAY commands allow your Amiga to speak!

        Say speech$

SET TALK
{[RAMOSPro_Examples:Examples/H-7/Help_73.AMOS,0,4]Set Talk}

SETs the style of synthetic speech which is generated by the SAY command.

        Set Talk sex,mode,pitch,rate

sex  =1 for female 
     =0 for male.

mode  toggles  the intonation system.  A value of one activates it and zero
turns it off.

pitch sets the tone of the speech from a low of 65 to a high of 320.

rate  enters the speed of the speech in words per minute.  Allowable values
range from 40 and 400.

TALK MISC
{[RAMOSPro_Examples:Examples/H-8/Help_83.AMOS,0,4]Talk Misc}

Set  the  volume  and  the  frequency  of  the  voice  used by the next SAY
instruction.

        Talk Misc volume,frequency

volume   : 0 to 64

frequency: 5000 to 25000.
TALK STOP
{[RAMOSPro_Examples:Examples/H-8/Help_83.AMOS,0,4]Talk Stop}

If you're using SAY in multitask mode, this shuts the Amiga up!

        Talk Stop

Multi-tasking

                          {[IAMOS HERE     ,4,3] Amos Here               }
                          {[IAMOS LOCK     ,4,3] Amos Lock               }
                          {[IAMOS TO BACK  ,4,3] Amos To Back            }
                          {[IAMOS TO FRONT ,4,3] Amos To Front           }
                          {[IAMOS UNLOCK   ,4,3] Amos Unlock             }
                          {[IMULTI WAIT    ,4,3] Multi Wait              }
AMOS HERE
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]=Amos Here}

AMOS  HERE  returns  a value of True (-1) if AMOS Professional is currently
displayed on the screen, and 0 if another Workbench application is visible.

        test=Amos Here 
AMOS LOCK
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]Amos Lock}

Stops  you  from  flicking  between  the  AMOS Professional display and the
Workbench screen using the Amiga+A keys.

        Amos Lock
AMOS TO BACK
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]Amos To Back}

Hides  the  AMOSPro  screen and allows you to access any other applications
which are running on your Amiga.

        Amos To Back
AMOS TO FRONT
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]Amos to Front}

Removes  the current application from the display, and replaces it with the
present AMOS screen.

        Amos To Front
AMOS UNLOCK
{[RAMOSPro_Examples:Examples/H-7/Help_70.AMOS,0,4]Amos Unlock}

Reverses  the  effect of the AMOS LOCK command and allows you to flick back
and  forth  between  AMOS  Professional  and  your  current  application by
pressing Amiga+A

        Amos Unlock
MULTI WAIT
{[RAMOSPro_Examples:Examples/H-5/Help_53.AMOS,0,4]Multi Wait}

Holds  your AMOS program, freeing time for the other applications which are
running   in   the   background.   It  should  not  be  used  for  accurate
synchronisation  effects  as  the  number of Vbl's depends on the number of
applications which are being executed using multi-tasking.

        Multi Wait
System Requesters

                        {[IREQUEST OFF,4,3] Request Off                  }
                        {[IREQUEST ON ,4,3] Request On                   }
                        {[IREQUEST WB ,4,3] Request Wb                   }

REQUEST OFF

Does  not  allow  the  AMOS  system  to  display the requester screens that
occasionally  pop  up  in  front  of  the current screen and REQUEST you to
perform an action, like inserting a disc.

        Request Off

REQUEST ON

Returns you to the normal or default REQUESTer mode. 

        Request On
REQUEST WB

Uses the standard Workbench Requestor for all messages.

        Request Wb

ERR$
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_2.AMOS,0,4]=Err$}

Returns  a string containing the chosen error message.  If the error number
is out of range, =ERR$() will return an empty string "" instead.

        s$=ERR$(Error_Number)

Note:  =ERR$() will only return a string if the error messages are actually
loaded in memory.

ERRN
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]=Errn}

Returns the identification number of a last error in your program.

        Print Errn
ERROR
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]Error}

Simulates an error and exits your program with an error message.

        Error n
ERRTRAP
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_2.AMOS,0,4]=Errtrap}

Returns   the   error  number  which  occurred  during  the  previous  TRAP
instruction.  If no error has been detected, you'll get a value of zero.

        test=Errtrap
ON ERROR
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]On Error}

ON  ERROR  can be used to detect and trap an ERROR without having to return
to the editor window.

        On Error Goto label
        On Error Proc name
RESUME
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]Resume}

Returns back to the statement that originally caused an error, after it has
been  dealt  with  by one of your ON ERROR routines.  If you specify a line
number the program will jump to that point instead.

        Resume linenumber

Also check out the RESUME LABEL and RESUME NEXT instructions.
RESUME LABEL
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]Resume Label}

Restarts your program after an error from the named LABEL.

        Resume Label labelname
RESUME NEXT
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_1.AMOS,0,4]Resume Next}

Resumes  your  program  after an error.  The program returns to the command
just after the instruction which generated it.

        Resume Next
TRAP
{[RAMOSPro_Tutorial:Tutorials/Error_Handling_2.AMOS,0,4]Trap}

TRAP executes a single instruction, and traps any errors which occur.  If a
problem  crops  up  during  this instruction, your program will continue as
normal.  You can now find the number of the error using =ERRTRAP

        Trap Normal_Instruction

Stop..Press
                       {[IHelpMemory   ,4,3] 1 Meg Users Read This!         }
                       {[IHelp3DCOMP   ,4,3] Compiler/3D Extensions         }
                       {[IHelpConfig   ,4,3] Important Configuration info   }
                       {[IHelpAdvert   ,4,3] Programmers/Artists read this  }
                       {[IHelpPecision ,4,3] Single and Double Precision    }
                       {[IHelpDithell  ,4,3] Procedures Library             }
                       {[IHelpCredits  ,4,3] Credits                        }

AMOS Interface Instructions
                       {[IHelpIops     ,4,3] Arithmetic Operations          }
                       {[IHelpIzones   ,4,3] Buttons and Edit Zones         }
                       {[IHelpIactive  ,4,3] Lists and Sliders              }
                       {[IHelpIgeneral ,4,3] General purpose commands       }
                       {[IHelpIgraphics,4,3] Text and Graphics              }
                       {[IHelpIbox     ,4,3] Resource commands              }


Interface Operations
        {[II!,4,3] ! String addition  } {[II/,4,3] / Divide           } {[II|,4,3] | Logical Or       }
        {[II#,4,3] # Number to string } {[II<,4,3] < Less than        } {[II-,4,3] - Minus            }
        {[II&,4,3] & Logical And      } {[II>,4,3] > Greater than     } {[II_MA,4,3] =MAx               }
        {[II*,4,3] * Multiply         } {[II=,4,3] = Equals           } {[II_MI,4,3] =MInimum           }
        {[II+,4,3] + Add              } {[II\,4,3] \ Not Equals       } {[II_NE,4,3] =NEgate            }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
Buttons and Edit Zones

                  {[II_BC,4,3] Button Change      } {[II_KY,4,3] KeYboard short-cut }
                  {[II_BP,4,3] =ButtonPosition    } {[II_NW,4,3] NoWait             }
                  {[II_BQ,4,3] ButtonQuit         } {[II_SZ,4,3] SetZonevar         }
                  {[II_BR,4,3] =ButtonReturn      } {[II_ZC,4,3] Zone Change        }
                  {[II_BU,4,3] create BUtton      } {[II_ZN,4,3] =Zone Number       }
                  {[II_DI,4,3] enter DIgits       } {[II_ZP,4,3] =Zone Position     }
                  {[II_ED,4,3] EDit zone          } {[II_ZV,4,3] =ZoneVar           }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
Lists and Sliders

                    {[II_AL,4,3] Active List                          }
                    {[II_AR,4,3] Array Read                           }
                    {[II_AS,4,3] Array Size                           }
                    {[II_IL,4,3] Inactive List                        }
                    {[II_HS,4,3] Horizontal Slider                    }
                    {[II_HT,4,3] HyperText                            }
                    {[II_SS,4,3] Set Slider                           }
                    {[II_VS,4,3] Vertical Slider                      }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
General purpose interface commands
        {[II_BA,4,3] BAse coordinates   } {[II_P3,4,3] =Parameter 3       } {[II_SM,4,3] Screen Move        }
        {[II_BX,4,3] =Base X            } {[II_P4,4,3] =Parameter 4       } {[II_SV,4,3] Set Variable       }
        {[II_BY,4,3] =Base Y            } {[II_P5,4,3] =Parameter 5       } {[II_SW1,4,3] =Screen Width      }
        {[II_CA,4,3] CAll machine code  } {[II_P6,4,3] =Parameter 6       } {[II_SX,4,3] =Size in X         }
        {[II_CX,4,3] =Center on X       } {[II_P7,4,3] =Parameter 7       } {[II_SY,4,3] =Size in Y         }
        {[II_EX,4,3] EXit program       } {[II_P8,4,3] =Parameter 8       } {[II_UI,4,3] =User Instruction  }
        {[II_IF,4,3] If..               } {[II_P9,4,3] =Parameter 9       } {[II_VA,4,3] =VAriable          }
        {[II_JP,4,3] JumP (goto)        } {[II_RT,4,3] Return (from JS)   } {[II_XA,4,3] =XA                }
        {[II_JS,4,3] Jump to Subroutine } {[II_RU,4,3] Run Until          } {[II_XB,4,3] =XB                }
        {[II_LA,4,3] LAbel              } {[II_SA,4,3] SAve block         } {[II_XY,4,3] XY                 }
        {[II_P1,4,3] =Parameter 1       } {[II_SH,4,3] =Screen Height     } {[II_YA,4,3] =YA                }
        {[II_P2,4,3] =Parameter 2       } {[II_SI,4,3] define block SIze  } {[II_YB,4,3] =YB                }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
Interface Text and Graphics commands

                  {[II_GB,4,3] Graphic Box        }  {[II_SF,4,3] Set Font           }
                  {[II_GE,4,3] Graphic Ellipse    }  {[II_SL,4,3] Set Line           }
                  {[II_GL,4,3] Graphic Line       }  {[II_SP,4,3] Set Pattern        }
                  {[II_GP,4,3] Graphic Plot       }  {[II_SW2,4,3] Set Writing        }
                  {[II_GS,4,3] Graphic Square     }  {[II_VT,4,3] Vertical Text      }
                  {[II_IN,4,3] INk                }  {[II_TH,4,3] =Text Height       }
                  {[II_PO,4,3] Print Outline text }  {[II_TL,4,3] =Text Length       }
                  {[II_PR,4,3] PRint text         }  {[II_TW,4,3] =Text Width        }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
Resource commands

                    {[II_BO,4,3] BOx                                  }
                    {[II_LI,4,3] LIne                                 }
                    {[II_ME,4,3] =MEssage                             }
                    {[II_PU,4,3] PUsh                                 }
                    {[II_UN,4,3] UNpack image                         }
                    {[II_VL,4,3] Vertical Line                        }

                    {[IHelpIntins,4,3] Return to Interface Instruction Menu }
String addition
Adds two strings together, leaving the address of the result.

   'string1' 'string2' !

Generates 'string1string2' and places it's address onto the stack.
Number to string
Converts a number into a string.  It can be used to print numbers using the
PR,PO, or VT commands.

   number1 #

Generates the string 'number1' and places it's address on the stack.
And
Performs a logical AND operation on two values from the stack.

   number1 number2 &
Mul
Multiplies the top two numbers on the stack, and leaves the result.

   number1 number2 *
Plus
Adds two numbers from the stack and returns the result.

   number1 number2 +
Div
Divides the second number on the stack by the top number.

   number1 number2 /
Less than
Compares  two  numbers on the stack, and returns a value of True(-1) if the
first is less than the second.

   number1 number2 <
Greater than
Compares  two  numbers  on the stack, and returns a value of True(-1) if the
first is greater than the second.

   number1 number2 >
Equals
Compares  two  numbers  on the stack, and returns a value of True(-1) if the
first is equal to the second.

   number1 number2 =
Not equals
Compares  two  numbers  on the stack, and returns a value of True(-1) if the
first is NOT equal to the second.

   number1 number2 \
Or
Performs a logical OR operation on two values from the stack.

   number1 number2 |
Subtract
Subtracts the second value from the first.

   number1 number2 -
Active List
Generates  a  selection  box which can be used to produce a wide variety of
file-selectors, or slider boxes.

AL zone,x,y,width,height,array address,first item,flag,paper,pen;[changes]

x,y  are  the coordinates of the window on the screen.  x is rounded to the
nearest 16.

width,height enter the width and height of the list window in characters.

array  address  holds  the  address  of  an  array  which you've previously
installed  into your Interface program using the ARRAY and VDIALOG commands
from Basic.

first item is the number of the first item in the list to be displayed.

flag is a bitmap containing three bits.

     Bit 0: If it's one AMOS adds a number to each item before it's
            displayed. Normally the count starts from zero.

     Bit 1: Used with bit 0. It starts the count from one.

     Bit 2: If this is zero, the item will be selected the moment it's
            highlighted with the mouse. If it's set to one, you'll need
            to click on the item first.

paper,pen hold the colours of the item text and the window background.

[changes]   is  a  list  of  Interface  commands  which  will  be  executed
automatically whenever an item is selected from the box.

Array Read
Reads a  value from an AMOS array. The address of this array should already
have  been  loaded  into  your Interface program using a combination of the
ARRAY,and VDIALOG commands.

   address_of_array element_number AR
Array Size
Returns the number of elements in an array stored at the specified address.

   address_of_array AS
BAse
{[RAMOSPro_Tutorial:Tutorials/Interface/Simple_requester.AMOS,0,4]BA}

Set the origin point of all future coordinate calculations.

   BA x,y;
Button Change
{[RAMOSPro_Tutorial:Tutorials/Interface/Working_buttons.AMOS,0,4]BC}

Changes the position of any active button.

   BC button number,new position;
BOx
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]BO}

Draws  a  rectangular bar out of an assortment of packed pictures found in
the resource bank.

   BOx x,y,first image,width,height;

x,y  define the position of the top left corner of the box.  As with the LI
command, the X coordinate will be rounded to the nearest multiple of eight.

first  image  is  the number of first of the 9 packed images to be used for
your box.

width and height set the dimensions of the box on the screen. The width must
be a multiple of the image width, but the height can be anything you like.

Button position

{[RAMOSPro_Tutorial:Tutorials/Interface/Working_buttons.AMOS,0,4]BP}

Returns the current position of your button.  It's normally used as part of
a button drawing routine to click the button down when it's selected.

   BP
Button Quit
{[RAMOSPro_Tutorial:Tutorials/Interface/Working_buttons.AMOS,0,4]BQ}

Makes  the  current  button  definition  an  EXIT button.  It's used in the
change  brackets  of  a  BU  function  to  trigger  a forced exit from your
dialogue box when your button is selected.

   BQ;
Button Return
{[RAMOSPro_Tutorial:Tutorials/Interface/Working_buttons.AMOS,0,4]BR}

Moves the current button to a new setting.

   BR new position;

It's normally called from inside a change routine to flip the button into a
new state when it's selected by the user.

BUtton
Defines a button for your dialogue boxes or control panels.

{[RAMOSPro_Tutorial:Tutorials/Interface/Working_buttons.AMOS,0,4]BU}

BU number,x,y,width,height,setting,minimum,maximum;[draw][change]

number  is  the  number of the button you wish to create starting from one.
If you want to link several button together you can assign them all to the
same ID number.

x,y  set  the  coordinates  of  the  top  left  hand corner of your button,
relative to the BAse point.

width,height hold the size of the button in pixels.

setting enters the initial position for your button.

minimum,maximum hold the smallest and highest values the setting can take.

[draw]  is  a  list of Interface instructions which will be used to display
your button on the screen.  These instructions will be called automatically
whenever the position value changes.

[change]  is a list of instructions which will be called up when the button
is  selected by the user.  If these commands change the position value, the
button will be redrawn using the previous [draw] routine.

=Base X
Returns the X coordinate of the origin point used for all future coordinate
calculations.   This value can be set up using either the BAse command from
AMOS Interface or directly from your Basic program.

   BX
=Base Y
Gets  the  Y  coordinate  of  the  origin  point used by the AMOS Interface
graphics commands.

   BY
CAll
Calls a machine code program from an interface routine.

   CAll address;

address  is  the  address of a machine code program in memory.  The easiest
way to load it, is to place it into a DBL variable from AMOS Basic:

Vdialog(1,0)=Start(6) :Rem Load 0 VA of channel 1 with the address of bank 6

You can now run your routine using a line like: CAll 0VA;

Your machine code can modify ALL registers, and should return with an RTS.
Centre Text
Finds  the  X  coordinate  needed  to  centre a piece of text neatly on the
screen.

   'text' CX
DIgit
{[RAMOSPro_Tutorial:Tutorials/Interface/Editing_Zones.AMOS,0,4]DI}

Creates a simple editing zone especially for numbers.  This zone allows you
to enter your numbers on the screen, and edit them directly with the cursor
keys.  Hitting Return will enter the value into memory.  It can now be read
using the RDIALOG function from your Basic program.

DI zone number,x,y,width,default,flag,paper,pen

zone number = the number of your zone.

x,y  are  the  coordinates  of  the start of your zone ralative to the BAse
point.  x will be rounded down to the nearest 16.

width enter the width of your zone in CHARACTERS.

default holds a value which will be returned as a default.

flag  selects  whether the default setting should be displayed in the zone.
If  it's  zero,  the  value  will  be  invisible,  and if flag=1 it will be
displayed as normal.

paper,pen are the colours of your text and background respectively.
EDit Ascii

{[RAMOSPro_Tutorial:Tutorials/Interface/Editing_Zones.AMOS,0,4]ED}

Creates  a  text  editing  zone  which  lets  you  enter  your  text on the
screen, and edit  it  directly  with  the cursor keys.  Hitting Return will
enter  the  value  into  memory.   It  can  now  be read using the RDIALOG$
function from your Basic program.

ED zone number,x,y,width,maxlength,'default',paper,pen

zone number = the number of your zone.

x,y  hold  the  coordinates  of the start of your zone ralative to the BAse
point.  x will be rounded down to the nearest 16.

width enters  the  width of your zone in CHARACTERS, rounded to the nearest
EVEN number.

maxlength sets  the  maximum number of characters which can be entered into
your string.

'default' is a string which will be returned as a default.

paper,pen are the colours of your text and background respectively
EXit
Ends an AMOS Interface program.  This should always be the LAST instruction
in your routine.

   EX;
Graphic Box
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]GB}

Draws  a  filled box in the present ink colour.  GB is ideal for generating
your buttons and dialogue boxes.

   GB tx,ty,bx,by;

Displays  a  box  from  tx,ty  to bx,by.  The colour of this box can be set
using  the  INk  command,  and  it's  fill  pattern  can be changed with SP
(SetPattern).

Graphic Ellipse
Draws a hollow ellipse, or circle at the appropriate point in your dialogue
box.

   GE x,y,radius1,radius2;

If  you  use  the  same  values for both radius1, and radius2, you'll get a
circle instead.

Graphic Line
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]GL}

Draws  a  line  on  the  screen  between  any two points in the current ink
colour.  The line style can be set using SL.

   GL x1,y1,x2,y2;

All coordinates are measured relative to the BAse point.
Graphic Plot
Plots a single point on the screen.

   GP x,y,colour number;

x,y are both measured relative to the BAse of the current dialogue box.
Graphic Square
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]GS}

Draws a hollow box on the screen in the current ink colour.

   GS tx,ty,bx,by;

All coordinates are measured relative to the BAse point.
Horizontal Slider
Draws a working horizontal slider bar on the screen.

{[RAMOSPro_Tutorial:Tutorials/Interface/Sliders.AMOS,0,4]HS}

HS zone number,x,y,width,height,position,trigger,total,step;[changes];

x,y = coordinates of the top left of the slider bar relative to the 
screen BAse.

width,height are the dimensions of the slider bar in pixels.

position  set the initial position.  Allowable position values range from 0
to "total"

trigger  enters  the  size  of  the movable block inside your slider bar in
units of total/width pixels.

total sets the maximum value which will be returned by the slider.

Allowable  positions range from 1 to total, with each "step" representing a
movement of total/width pixels.

step  controls the distance which will be moved whenever the user clicks on
the background area of the slider.

[changes]  holds  a  list  of  Interface  commands  which  will be executed
whenever the slider is moved by the user.

HyperText
Generates  a  hypertext  window, similar to the help system.  Your text can
include  either  normal  ascii characters, or "hypertext zones".  Each zone
consists of the following;

   {[ value ] highlighted text}
or
   {[value,paper,pen] highlighted text}

HT zone,x,y,width,height,textaddress,startline,buffer,paper,pen;[changes]

zone = number of your zone

x,y  set the coordinates of top left hand corner of text window.  x will be
rounded down to the nearest multiple of 16.

width,height = the size of the display window in characters.

textaddress = address in memory of the first character in your text.

startline = the number of the first line to be displayed in your text.

buffer  sets  the  size  of  an  internal buffer area.  Each hypertext zone
requires eight bytes.

paper,pen are the colour of the ink and paper colours used by your text.

[changes] is a routine which will be called whenever the user clicks on one
of your hypertext zones.

If..then
Executes  an  Interface routine if the result of an expression is True (non
zero).

   IF expression;[do if true]

expression can contain the following operations:

= equals
\ not equals
> greater than
& and
| or

The routine between the brackets [] can be as long as you like.  You're not
just limited to a single line.

Inactive List

Generates  a  window full of items which CANNOT be selected with the mouse.
These windows are fine for displaying lists of information on the screen.

IL zone number,x,y,width,height,array address,first item,flag,paper,pen;

x,y  hold the coordinates of the window on the screen.  x is rounded to the
nearest 16.

width,height set the width and height of the list window in characters.

array  address  enters  the  address  of  an  array which you've previously
installed  into your Interface program using the ARRAY and VDIALOG commands
from AMOS Basic.

first item = the number of the first item in the list to be displayed.

flag = a bitmap containing two bits.

   Bit 0: If it's one AMOS adds a number to each item before it's
          displayed. Normally the count starts from zero.

   Bit 1: Used with bit 0. It starts the count from one.

paper,pen are the colours of the item text and the window background.
INk
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]IN}

Set ink,paper and outline colours used by your graphics.

   IN pen,paper,outline;
Jump
Jumps to a label in your Interface program.  This must have been previously
set up using the LAbel instruction.

   JP labelnumber;
Jump to Subroutine
Calls a subroutine in your AMOS Interface program.

   JS label number;

The label should have been previously defined using the LA command.  At the
end  of  your  subroutine,  you  can  return  to  your main program with RT
(ReTurn)

KeY
Set a keyboard short-cut.  Assigns a control key combination to the current
button definition.

   KY ascii,shift;

ascii  enters  the  ASCII code of your chosen key.  Values from 128 onwards
represent scan codes instead.

shift specifies on option list of shift,alt,or control settings.  These are
entered using a simple bit-map.  See KEY SHIFT for more details.

Label
Creates  a  label  in  your  Interface  program for use with the JUmp or JS
commands

   LA label number;

Allowable label numbers range from 0 to 65535.
LIne
Draws  a  line  of  images  from  a  series of three components held in the
resource  bank.   These  components  can  be  created  with the help of the
resource  editor,and  used  to produce attractive buttons for your dialogue
boxes.

   LI x,y,first image,width;

width  should  be  an  exact  multiple  of  the  width  of your components.
Otherwise, you may get some pretty strange effects.

Also  note  that  the  x  coordinate  will  be automatically rounded to the
nearest multiple of eight.

MAximum
Reads two values from the calculation stack, and returns the largest one.

   value1 value 2 MA
MEssage
Takes a message from the resource bank, and places it on the stack.

   number ME

MInimum
Grabs two values from the calculation stack, and returns the smallest one.

   value1 value2 MI
NEg
Flicks a number from positive to negative.

   number1 NEg

Returns a value of -number1.
NoWait
Used inside the Bchange part of a button definition to ensure that commands
take effect the moment the button has been selected.  So there's no need to
wait for the mouse key to be released.

   NW;
Param 1
Reads  the  first  parameter  value  entered  into User defined instruction
created with UI.

   P1
Param 2
Gets the second parameter from a User defined instruction created by UI.

   P2
Param 3
Returns the third parameter from a User defined instruction created by UI.

   P3
Param 4
Gets  the fourth parameter value from a User defined instruction created by
UI.

   P4
Param 5
Reads  the fifth parameter value from a User defined instruction created by
UI.

   P5
Param 6
Returns  the  sixth parameter value from a User defined instruction created
by UI.

   P6
Param 7
Reads  the  seventh parameter value from a User defined instruction created
by UI.

   P7
Param 8

Grabs the eighth parameter value from a User defined instruction created by
UI

   P8
Param 9
Returns  the  final parameter value from a User defined instruction created
by UI.

   P9
Print Outline
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]PO}

Displays some outlined text on the screen.

   PO x,y,'text',outline colour,text colour;
PRint
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]PR}

Prints some TEXT on the screen.

   PR x,y,'text',ink;

x,y are the coordinates, relative to the screen base.

'text' holds your text. You can also use a variable in this position.
PUsh
Sets an offset to the first image in the resource bank.

   PU start;

start is a number to be added to all future image numbers.

RTs
Returns from a subroutine you've previously entered with the JS command.

   RTs;
Run Until

{[RAMOSPro_Tutorial:Tutorials/Interface/Simple_requester.AMOS,0,4]RU}

Holds  the  dialogue box on the screen until a specified list of conditions
have been met.

   RU delay,flags;

delay  is  a  time  period  in  50th's  of  a second.  If it's greater than
zero,the  Interface  program  will automatically terminate after your chosen
interval.

flags set the condition to be tested, using a simple bitmap.

Bit 0  Clears all current keypresses
Bit 1  Clears the status of the mouse buttons
Bit 2  Exits whenever a key is pressed on the keyboard
Bit 3  Quits when a mousekey is clicked
SAve

{[RAMOSPro_Tutorial:Tutorials/Interface/Autocentering.AMOS,0,4]SA}

Saves the background area underneath your dialogue box using a numbered memory
block.

   SA block number;

The  size  of this block is defined using the SI; command.  If you omit the
block  number,  AMOS  will automatically use the first free block available
from  memory.  So if you've a lot of dialogue boxes, you don't have to keep
track of all the block numbers.

SetFont
Sets  the  text  font  used by the PR,PO,ME, and VT commands.  Before using
this  option,  you should examine the fonts on the disc with GET FONTS from
AMOS Basic.

   SF font,style;

Use a value of zero for the font if you just want to set the style.
Screen Height
Returns the height of the current AMOS screen.

   SH
SIze
Defines the size of the area to be saved underneath the dialogue box.

{[RAMOSPro_Tutorial:Tutorials/Interface/Autocentering.AMOS,0,4]SI}


   SI width,height;

Specifies a save area from the coordinate base (x,y) to (x+width,y+height).
The area can now be set up with a SA command.

SetLine
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]SL}

Sets the line style used by the GraphicLine command.

   SL bit-pattern;

bit-pattern  is  a  list  of  16  binary  noughts and ones which define the
appearence of the lines.  See the SET LINE command from AMOS Basic.

Screen Move
Called  as  part  of  a  button  change  routine to drag the current screen
whenever the item is selected.

   SM;
Set Pattern
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]SP}

Sets the fill pattern used by the GraphicBox command.

   SP pattern number,outline mode;

pattern is the number of a fill pattern from 0 to 34.

outline =1 for an outline or 0 to remove it.
Set Var
Sets an internal Interface variable.

   SV index number,value;

value can be either a number, or string enclosed by single quotes. ''

Screen Width
Gets  the  width  of  the current AMOS screen.  It's used to create general
purpose  dialogue  boxes  which  automatically  tailor  themselves  to your
display.

   SW
SetWriting
{[RAMOSPro_Tutorial:Tutorials/Interface/Graphics.AMOS,0,4]SW}

Sets the writing mode use for all future graphics operations.

   SW mode;

See the AMOS SET WRITING command for a list of the available modes.
Size in X
Returns  the width of your dialogue box which you've previously set up with
the SI command.

   SX
Size Y
Returns  the  height  of  your  present  dialogue box.  This must have been
entered previously using the SIze command.

   SY
SetZonevar
Sets  an internal "zone variable" which can be accessed from your next zone
definition.   It  can  be  exploited  as  part  of  a  User  Instruction to
permanently poke vital data into a user defined button type.

   SZ value;

Also see the ZV function.
SetSlider
Sets the appearance of the slider bars created with HS,or VS.

   SS b1,b2,b3,pb,s1,s2,s3,ps;

b1,b2,b3 enter the ink,paper and outline colours for the background of the
slider.  bp specifies the fill pattern to be use.

s1,s2,s3,sp  define  the  ink,paper,outline and fill pattern of the slider
box.

Text Height
Returns the height of the present text font, measured in pixels.

   TH
Text Length
Returns the number of characters in a piece of text.

   'text' TL
Text Width
Returns the width in pixels of a piece of text.

   'text' TW
User Instruction
Defines a brand new Interface instruction for use with your program.

UI XX,number of parameters;[instruction definition]

XX = the name of your command using two UPPERCASE characters.  The new name
must  be  unique.   You can't use the name of any of the original Interface
instructions.

number  of parameters = a number from 1 to 9 which tells Interface how many
values will be entered into the instruction.  These values can be read from
your UI routine using the functions P1 to P9.

[instruction  definition] = a list of Interface commands which will be used
to define your new instruction.  This list can be as long as you like.

UNpack
Unpacks an image from the resource bank, and displays it on the screen.

   UN x,y,image;

Displays  the requested image at coordinates x,y RELATIVE TO THE COORDINATE
BASE.

Variable
Reads a value from an internal variable.

   index number VA

index  number  normally ranges from 0 to 16, but if you increase the number
of  variables  using  the DIALOG OPEN command, you can obviously use larger
ranges.

VLine
Draws  a  vertical  line  out  of  a series of three components held in the
resource bank.

   VLine x,y,first image,height;

x,y enter the coordinates of the top left corner of your line.

first  image  sets  the first of the three components which will be used to
display your line on the screen.

height  specifies  the height of your line in pixels.  This should an exact
multiple of three.

Vertical Slider
{[RAMOSPro_Tutorial:Tutorials/Interface/Sliders.AMOS,0,4]VS}

Draws a working vertical slider bar on the screen.

VS zone number,x,y,width,height,position,trigger,total,step;[changes];

x,y = coordinates of the top left of the slider bar relative to the screen 
BAse.

width,height are the dimensions of the slider bar in pixels.

position  set the initial position.  Allowable position values range from 0
to "total"

trigger  enters  the  size  of  the movable block inside your slider bar in
units of total/height pixels.

total  sets  the  maximum  value  which  will  be  returned  by the slider.
Allowable  positions range from 1 to total, with each "step" representing a
movement of total/height pixels.

step  controls the distance which will be moved whenever the user clicks on
the background area of the slider.

[changes]  holds  a  list  of  Interface  commands  which  will be executed
whenever the slider is moved by the user.

VText
VT prints your text downwards on the screen.

VerText x,y,'text',pen;

x,y hold the coordinates of the first character in your string.  All future
characters will be neatly positioned below the initial letter, allowing you
to create effective vertical buttons.

    O
    K
    ?

'text' enters your message to be displayed.

pen sets the colour of your characters.

XA
Gets the X coordinate of the graphics cursor BEFORE the most recent drawing
operation was performed.  It's used to line up the various elements on your
display.

   XA
XB
Returns  the  X  coordinate  of  the  graphics cursor AFTER the most recent
drawing operation was performed.

   XB
XY
Sets  the  internal  variables  XA,YA,XB,YB.   It's  called  as  part  of a
UserInstruction to mimic the behaviour of the built-in graphics commands.

   XY xa,ya,xb,yb;

YA
Finds  the  Y  coordinate  of  the graphics cursor BEFORE the most recent
drawing operation was performed.  It's used to line up the various elements
on your display.

   YA
YB
Gives  you  the  Y  coordinate of the graphics cursor AFTER the most recent
drawing operation was performed.

   YB

Zone change
Changes  the position value of another zone.  It's used as part of a change
routine to link several objects together.

   ZC zone_or_button_number,new data;

If  several zones have the same number, they can all be changed by a single
operation.

ZoneNumber
Returns the number of the current zone.  It's used to allow the creation of
user defined button types with UI.

   ZN

A typical example would be:

   ZC ZN 1+,ZP load the next zone with the present position
Zone Position
Returns  the  position  of  the current zone.  Depending on the type of the
zone  the  position  could  be  a  number (buttons,sliders,DIgit zone) or a
string (EDit zones).

   ZP

ZP is generally used as part of a zone change routine to redraw your object
as the position changes.

ZoneVar
ZV  can  only  be  used  inside  the  draw  or  change  brackets  of a zone
definition.  It reads the contents of the internal zone variable, and pokes
it permanently into your definition.

   ZV
The Amos Animation Language (AMAL)
            {[IA_A ,4,3] Anim       } {[IA_J ,4,3] Jump       } {[IA_O ,4,3] On         } {[IA_EX,4,3] =eXit      }
            {[IA_AU,4,3] AUtotest   } {[IA_J0,4,3] Joy(0)     } {[IA_P ,4,3] Pause      } {[IA_XH,4,3] =XHard     }
            {[IA_BC,4,3] =BobCol    } {[IA_J1,4,3] Joy(1)     } {[IA_PL,4,3] PLay       } {[IA_XM,4,3] =XMouse    }
            {[IA_C ,4,3] =Col       } {[IA_K1,4,3] =mouseKey 1} {[IA_R ,4,3] Register   } {[IA_XS,4,3] =XScreen   }
            {[IA_D ,4,3] Direct     } {[IA_K2,4,3] =mouseKey 2} {[IA_SC,4,3] =SpriteCol } {[IA_YH,4,3] =YHard     }
            {[IA_E ,4,3] End        } {[IA_L ,4,3] Let        } {[IA_T ,4,3] To         } {[IA_YM,4,3] =YMouse    }
            {[IA_F ,4,3] For        } {[IA_M ,4,3] Move       } {[IA_V ,4,3] VUmeter    } {[IA_YS,4,3] =YScreen   }
            {[IA_I ,4,3] If         } {[IA_N ,4,3] Next       } {[IA_W ,4,3] Wait       } {[IA_Z ,4,3] =Zandom    }


            {[IA_X ,4,3] =X coord   } {[IA_Y ,4,3] =Y coord   } {[IA_AR,4,3] =A image no} {[IA_ED,4,3] Amal Editor}
Anim
Animate an object through a number of different images.

        Anim times,(image,delay)(image delay)....

times = the number of times the animation will be repeated. 
        A value of zero means repeat forever.

image = the number of an image from the object bank to be displayed.

delay = the period of time the image will be held on the screen, in
        fiftieths of a second.
A register
This  special  AMAL  register holds the current object image which is being
displayed  on the screen.  Alternatively, if you`re animating a raindow, it
stores the height of your rainbow instead.

        


Autotest
Adds  a  special  test  at  the start of your AMAL program which is checked
automatically every VBL before your AMAL commands are executed.

        AU(list of AMAL instructions)
BobCol
Checks for a collision between one or more Blitter objects.  It can only be
used in conjunction with the SYNCHRO system.

        =BC(target,first,last)

Tests bob number TARGET for collisions between objects FIRST and LAST.  The
result will be -1 if a collision has occurred, otherwise 0.

Col 

Tests the status of an object after a collision has been detected using =SC
or =BC.

        =C(object)

object  is  the  number of your Sprite or Bob.  If this object has collided
with the target object, you'll get a value of -1, otherwise 0.

Direct
Selects the point to restart your AMAL instructions to be executed after an
Autotest.

        Direct Label

Label is an AMAL Label you've defined in your main AMAL program.
End
Terminates  your  AMAL program, and stops the Autotest feature if it's been
activated.

        End
AMAL Editor
The  AMAL  Editor  is a utility program which allows you to enter your AMAL
programs directly on the screen, and save them into an AMAL memory bank for
future  use. 

It  also  includes  a powerful debugging system which lets you step through
your AMAL programs a line at a time.

Last,  but  not  least, there`s a Path Definer for creating smooth movement
patterns for use with the AMAL PLay command.

See  the  Accessory  section  of  the  AMOS Professional User Guide for
further details.

For
Used  as  part of a For..To..Next loop.  This allows you to repeat parts of
your AMAL program a set number of times.

        For reg=start To end
        :AMAL  instructions:
        Next

reg can be any AMAL register from R0 to R9 and RA through RZ.

start and end can be any AMAL expression you wish.
If 
Performs a simple test in your AMAL programs.

        If expression Jump Label

Evaluates  the  expression  and  jumps  to  Label  if it returns a value of
TRUE(-1).

        If expression Direct Label

Chooses the part of your program to be executed after an Autotest. 

        If expression eXit

Leaves an Autotest immediately.

mouse Key 1
Checks  the Left mouse button for a keypress.  If it's been clicked, you'll
get a value of of -1, otherwise 0

        If K1 Jump Label
mouse Key 2
Examines  the  Right  mouse  button  for a keypress.  If it's been clicked,
you'll get a value of of -1, otherwise 0

        If K2 Jump Label
Jump
Jumps to a label in your AMAL program. 

        Jump Label  
Joy(0)
Tests  the  Right  joystick  and  returns a bit-map containing it's current
status.  See the AMOS JOY command for more details.

        If J0=1 Jump Up
Joy(1)
Monitors  the  Right joystick and returns a bit-map containing it's current
status.  See the AMOS JOY command for more details.

        If J1=1 Jump Up

Let
Assigns a value to an AMAL register.

        Let Rn=expression

n can be 0 to 9 for local registers, and A through Z for global ones.

You can also use the special registers A,X, and Y.
Move
Moves an object through a fancy pattern.

        Move horizontal distance,vertical distance,steps

horizontal distance is the total distance to be moved across the display.

vertical distance holds the total distance to be moved down.

Negative values reverse the direction!

steps enters the number of stages the movement will be divided up into.
Next
Used  after  a  For..To..statement to jump back to the first instruction in
the loop.

        For reg=start To end
        :AMAL  instructions:
        Next
On
Restarts your main AMAL program after a Wait command.

        On

Pause
Halts your AMAL program until the next vertical blank, just like the Basic
WAIT VBL command.

        Pause
Play 
Plays  a recorded movement pattern stored in the AMAL bank.  These patterns
are set up using the AMAL EDITOR accessory.

        PLay path number

R0 holds the time between each movement step, and R1 stores the direction.

R1=0   reverses the pattern.
R1=-1  stops it.
Registers 
Represents one of the AMAL variables. There are two different sorts.

Local registers: R0 to R9

Each  AMAL  channel  has  it's  own  set  of  Local  registers,  completely
independantly.

Global registers: RA through RZ

These  retain  the  same values between all AMAL programs.  So there's just
one set for the entire system.

Sprite Col
Tests  for a collision between one or more Sprites.  It can only be used in
conjunction with the SYNCHRO system.

        =SC(target,first,last)

Inspects  sprite  number  TARGET  for  collisions between objects FIRST and
LAST.  The result will be -1 if a collision has occurred, otherwise 0.

To
Used in a For..To..Next structure.

        For reg=start To end
        :AMAL  instructions:
        Next
VUmeter
Gets  the  intensity  of  a  voice  in  some  music which is running in the
background.  The intensity varies from 0 (silent) to 63 (very loud).

        Let Rn=VU(voice)
    
voice is the number for the voice to be tested from 0 to 3.
Wait
Freezes your AMAL program completely, and only executes an Autotest.

        Wait
X
Holds the X coordinate of your object on the screen.

        =X

In  the  case  of  rainbows, the X register stores the BASE of your rainbow
effect.

XHard
Converts  a  screen  coordinate  into  a  Hardware  coordinate for use with
sprites or screens.

        =XH(screen,x)

screen is the number of the screen to be used as the coordinate base.
eXit
Leaves an Autotest and returns to the main AMAL program.

        eXit
XMouse
Returns the X coordinate of the mouse pointer in HARDWARE format.

        Let X=XM
XScreen
Translates an X coordinate from Hardware format to screen format.

        =XS(screen,xh)

screen is the number of the screen to be used as the coordinate base.
Y
Holds the Y coordinate of your object on the screen.

        =Y

If  you`ve assigned your AMAL channel to a Rainbow, Y contains the hardware
coordinate of the first Rainbow line on the screen.


YHard
Turns  a Y coordinate relative to the screen into a Hardware coordinate for
use with sprites or screens.

        =XH(screen,x)

screen is the number of the screen to be used as the coordinate base.
YMouse
Returns the Y coordinate of the mouse pointer in HARDWARE format.

        Let Y=YM
YScreen
Transforms a Y coordinate from Hardware format to screen format.


        =YS(screen,yh)

screen is the number of the screen to be used as the coordinate base.
Zandom number
Generates  a  random number from -32767 to 32768.  The range of the numbers
is  set  via  a  bit-mask,  which is combined with the return value using a
logical AND  operation.  It's  easiest to enter the range as just less than
an  exact  power  of  two,  such as 31, 63, 127, or 255.  This will provide
you with random numbers from 0-31, 0-61, etc.

        Let X=Z(255)

The  reason  for the odd name, is that we ran out of letters!  If we`ve had
the option, it would have been called R for random!

Embedded Menu Commands
                        {[IM_BA ,4,3] BAr                                }
                        {[IM_BO ,4,3] BOb                                }
                        {[IM_EL ,4,3] ELipse                             }
                        {[IM_IC ,4,3] ICon                               }
                        {[IM_IN ,4,3] INk                                }
                        {[IM_LI ,4,3] LIne                               }
                        {[IM_LO ,4,3] LOcate                             }
                        {[IM_OU ,4,3] OUtline                            }
                        {[IM_PA ,4,3] PAttern                            }
                        {[IM_PR ,4,3] PRoc                               }
                        {[IM_RE ,4,3] REserve                            }
                        {[IM_SF ,4,3] Set Font                           }
                        {[IM_SL ,4,3] Set Line                           }
                        {[IM_SS ,4,3] Set Style                          }


Embedded  menu  commands  define  the  appearance of a menu item when it is
selected  on  the  screen.   You can include them as part of the definition
string entered into the MENU$ function.

All embedded commands consist of just two letters entered in UPPER or lower
case.   Any  other  characters will be ignored.  Most commands also require
parameter  values as well.  Parameters should be entered as simple numbers,
since expressions will NOT be evaluated.
BAr
Draws a rectangular Bar at the current cursor coordinates.

        BA x,y

The bar is drawn from the existing graphics cursor to coordinates x,y.  The
colour  of  this  bar  is  set with INk, and the style is defined using the
OUtline and PAttern commands.
BOb

Displays a bob in the menu item starting at the current cursor position.

        BO bob number

The  bob  is drawn from the top left corner of your image, totally ignoring
the Hot Spot.

ELlipse

Draws an ellipse centred at the present cursor postion.

        EL r1,r2

r1,r2  enter  the  radii  of  the  ellipse.   Set them to the same value to
generate  a  circle.   The  colour of your ellipse is defined using the INk
instruction.

ICon

Draws an Icon in the item at the current cursor position

        IC icon number
INk

Sets the colours used by all future text and graphics operation in your menu.

        IN mode,index

mode is a value from 1 to 3.

Mode =1 Set TEXT colour
Mode =2 Set BACKGROUND colour
Mode =3 Set OUTLINE colour
LIne
Draws a line from the current cursor position to x,y

        LI x,y
LOcate 
Moves  the  graphics cursor used as the position for your text and graphics
operations.

        LO x,y

x,y  are the new coordinates of the cursor measured RELATIVE to the top left
corner of the present menu line.
OUtline

Draws a border in the current OUTLINE colour around any bars created with the
BA command.

        OU 1 

Activates outline.

        OU 0

Turns it off.
PAttern
Sets the fill pattern used by the BAr command.

        PA fill pattern

Allowable fill patterns range from 1 to 34. 
PRoc
Calls an AMOS PRocedure whenever the item is selected by the user.

        PR name

See the AMOSPro User Guide for more information. It's quite involved!    
REserve
RE allocates n bytes of workspaces for use with the PRoc command.
            
        RE n

SFont

Changes the graphics font used by your menu text. Before using this command,
you'll need to call GET FONTS from your AMOS Basic program.

        SF font
SLine
Enters  a  16  digit  bit  pattern  which  redefines  the appearance of any
subsequent lines which are drawn on the screen.

        SL bitpattern

Check out the AMOS SET LINE command for more details.
SStyle
Sets the style used by the current text font.

        SS style

style is a bitmap which controls the appearence of your text. 

Each  bit  changes a specific attribute.  If it's set to one, the attribute
is selected.

Bit 0    Set Underline        
Bit 1    Set Bold
Bit 2    Set Italics 
Editor key commands
                        {[IHelpEditC ,4,3] Cursor keys                  }
                        {[IHelpEditE ,4,3] Editing keys                 }
                        {[IHelpEditV ,4,3] Cut and paste                }
                        {[IHelpEditF ,4,3] Function keys                }
                        {[IHelpEditMk,4,3] Marker keys                  }
                        {[IHelpEditS ,4,3] Search and replace           }
                        {[IHelpEditT ,4,3] Tabulation keys              }
                        {[IHelpEditP ,4,3] Program control keys         }


                        {[IHelpEditH ,4,3] Help Keys                    }

Cursor keys
Here  is a list of all the AMOS Professional control keys available when in
the  Main  Editor  and their usage.  If you've changed the key combinations
that select your menu items, this list will be wrong.

[Left]                  Move cursor one space left.
[Right]                 Move cursor one space right.
[Up]                    Move cursor up to next available line.
[Down]                  Move cursor down to next available line.

[Shift]+[Left]          Move cursor to previous word.
[Shift]+[Right]         Move cursor to next word.
[Shift]+[Up]            Move cursor to top line of current page.
[Shift]+[Down]          Move cursor to bottom line of current page.

[Ctr]+[Up]              Display previous page.
[Ctr]+[Down]            Display next page.

[Shift]+[Ctr]+[Up]      Jump to start of program.
[Shift]+[Ctr]+[Down]    Jump to end of program.

Editing keys
[Backspace]             Delete character to the left of cursor.
[Del]                   Delete character at cursor current location.
[Return]                Enter current line/Split existing line.
F10                     Insert a line at current position.
[Control]+[Q]           Clear current line.
[Control]+[Y]           Clear line and move up text to fill gap.
[Control]+[Del]         Delete to end of line.
[Control]+[Backspace]   Delete to start of line.
[Shift]+[Backspace]     Delete word to left.
[Shift]+[Del]           Delete word to right.

Function Keys
F1                      Run program
F2                      Test program
F3                      Indent program
F4                      Enter Monitor
F5                      Help
F6                      Previous window
F7                      Next Window
F8                      Toggle Insert mode
F9                      Open/Close Procedure
F10                     Insert line

These keys are also available from the icons at the top of the Editor screen
Cut and paste
[Control]+[B]           Activate/Deactivate block mode.
[Control]+[A]           Select entire program.

[Control]+[S]           Store block in memory and leave block on screen.
[Control]+[C]           Cut block.  Erase from screen and  load  into memory.
[Control]+[P]           Paste block at current cursor position.  
[Control]+[F]           Deselect block, remove highlighting.

[Control]+[Shift]+[P]   Print block
[Control]+[Shift]+[S]   Save block.
[Control]+[Shift]+[A]   Save block in Ascii format.

Marker keys
[Shift]+[Ctrl]+[number] Set a marker at current cursor position, with number
                        between 0 and 9 from numeric keypad.

[Ctrl]+[number]         Jump to previously set marker numbered 0 to 9 from
                        numeric keypad.
Search and replace
[Amiga]+[F]             Find first occurrence of selected text from cursor.
[Amiga]+[N]             Find next occurrence of selected text.
[Amiga]+[P]             Find previous ocurrence of selected text.

[Amiga]+[Shift]+[F]     Replace text with new text and jump to next
                        occurrence.
[Amiga]+[Shift]+[N]     Find next occurrance of text and replace it.
[Amiga]+[Shift]+[P]     Replace last occurrence of your text.

[Alt]+[Up]              Search back through program to last label or procedure
                        definition.
[Alt]+[Down]            Search forward in program to next label or procedure
                        definition.
Tabulation keys
[Ctrl]+[Tab arrows]     Set Tab stop.
[Tab arrows]            Move whole line at current cursor position to next
                        Tab.
[Shift]+[Tab arrows]    Move whole line at current cursor position to last
                        Tab.
Program control keys
[Amiga]+[Shift]+[S]     Save program under new name.
[Amiga]+[S]             Save program under existing name.
[Amiga]+[L]             Load program

[Esc]                   Go to direct Mode.

Help Keys
[Help]            Open Help Window.
F5                Open Help Window.

Esc               Leave Help Window.
[Up Arrow]        Scroll Window up.
[Down Arrow]      Scroll Window down.
Direct mode editing keys
Here is a list of the editing keys and their effects when in Direct Mode.

[Backspace]             Delete character to the left of cursor.
[Del]                   Delete character at cursor current location.
[Return]                Execute current line of commands.
[Left]                  Move cursor one space left.
[Right]                 Move cursor one space right.
[Shift]+[Left]          Move cursor to previous word.
[Shift]+[Right]         Move cursor to next word.
[Up]                    Moves the history buffer to the previous line
[Down]                  Scrolls the next line from the history buffer
[Esc]                   Leave Direct Mode.  Go to main editing window.
[Control]+[Up]          Moves the entire direct mode window up.
[Control]+[Down]        Moves the direct mode window down.
[Shift]+[Up]            Reduces the size of the direct mode window.
[Shift]+[Down]          Expands the direct mode window

Note:Run does not work from direct mode.

AMOS Professional Syntax conventions

                        {[IHelpData ,4,3] Datatypes                     }
                        {[IHelpInstr,4,3] Instructions                  }
                        {[IHelpFunct,4,3] Functions                     }
                        {[IHelpVar  ,4,3] Reserved Variables            }
Datatypes

AMOS allows you to use several types of variables in your programs.

Type                  Example          Min      Max
---------------------------------------------------------------

Integer               A=3              -65536   65536

Single Precision      A#=3.14159       1E-14    1E+15

Double Precision      A#=3.1415926543  1E-307   1E+308

String                A$="AMOS"        0 chars  65536 chars

Double  Precision  numbers  and Single Precision numbers cannot be mixed in
the  same  program.   If  you want to use double precision, insert a DOUBLE
PRECISION command at the START of your listing.

Instructions
These are normal AMOS commands such as:

Print,Stop,Input,Text,Centre,or Sprite

They perform a single action in your AMOS Basic program, without generating
a return value.
Functions
Like  instructions,  but  they  return  a value which can be printed on the
screen or assigned to a variable.

Examples include:

     Len(),Instr(),Chip Free,=Screen

Reserved variables
Are  internal  variables  which  hold  vital  information  for  use by your
program.  They can often be assigned new values as well.

Typical examples are:

Timer,X Mouse,Y Mouse,Dreg(),Areg(),Menu$()
Windows

                  {[IBORDER      ,4,3] Border      } {[ITITLE BOTTOM,4,3] Title Bottom} {[IWINDON     ,4,3] =Windon     }
                  {[ICLW         ,4,3] Clw         } {[ITITLE TOP   ,4,3] Title Top   } {[IWIND OPEN   ,4,3] Wind Open   }
                  {[IHSCROLL     ,4,3] Hscroll     } {[IVSCROLL     ,4,3] Vscroll     } {[IWIND SAVE   ,4,3] Wind Save   }
                  {[ISCROLL ON   ,4,3] Scroll On   } {[IWIND CLOSE  ,4,3] Wind Close  } {[IWIND SIZE   ,4,3] Wind Size   }
                  {[ISCROLL OFF  ,4,3] Scroll Off  } {[IWIND MOVE   ,4,3] Wind Move   } {[IWINDOW      ,4,3] Window      }
CLW
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]Clw}

Erases the contents of the current text window and fills it will a block of
the present PAPER colour.

        Clw
HSCROLL
{[RAMOSPro_Examples:Examples/H-2/Help_22.AMOS,0,4]Hscroll}

Scrolls some text in your current window horizontally by a single character.

        Hscroll type

Type can take one of four values:

1 = Move current line to the left
2 = Scroll entire text  to the left
3 = Move current line to the right
4 = Scroll text to right
SCROLL OFF
{[RAMOSPro_Examples:Examples/H-2/Help_22.AMOS,0,4]Scroll Off}

Stops  your  text  scrolling up when you print past the bottom of your text
window.  The text now restarts from the top.

        Scroll Off
SCROLL ON
{[RAMOSPro_Examples:Examples/H-2/Help_22.AMOS,0,4]Scroll On}

Re-activates the standard text scrolling system.

        Scroll On
TITLE BOTTOM
{[RAMOSPro_Examples:Examples/H-3/Help_31.AMOS,0,4]Title Bottom}

Assigns a piece of text to the bottom line of your text window.

        Title Bottom title$
TITLE TOP
{[RAMOSPro_Examples:Examples/H-3/Help_31.AMOS,0,4]Title Top}

Displays a title string along the top of your text window.

        Title Top title$

VSCROLL
{[RAMOSPro_Examples:Examples/H-2/Help_22.AMOS,0,4]Vscroll}

Scrolls some text in your current window vertically by a single character.

        Vscroll type

Type can take one of four values:

1 = Move all text on the current line and below one place down

2 = Move all text on or below the cursor line one place up

3 = Scroll up lines from the top of the window to the cursor line.

4 = Scroll down lines from top of window to current cursor position.

WIND CLOSE
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]Wind Close}

Removes  the  current  text  window  from  the  screen, along with all it's
contents. If  you've  saved  the  background area with WIND SAVE it will be
restored to it's original position.

        Wind Close

WIND MOVE
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]Wind Move}

Moves the current text window to a new position on the screen.

        Wind Move x,y

x,y  are  GRAPHICS  coordinates. x is automatically rounded down to the
nearest multiple of 16.

WIND OPEN
{[RAMOSPro_Examples:Examples/H-3/Help_31.AMOS,0,4]Wind Open}

Opens  a  new  text  window on the screen.  This will be used by all future
PRINT,INPUT, or cursor commands.

        Wind Open n,x,y,w,h
        Wind Open n,x,y,w,h,border

x,y  are  the screen coordinates of the window.  The X coordinate's rounded
to the nearest multiple of sixteen.

w,h  enter  the  width  and  height of the window in characters.  They must
divide evenly by 2.

border  is an option border ranging from 1 to 16.  Only borders 1 through 3
are presently available.

WIND SAVE
{[RAMOSPro_Examples:Examples/H-3/Help_31.AMOS,0,4]Wind Save}

Activates  window  saving  mode.  Whenever a window is created, the area of
the  screen  underneath  it  will  be  automatically saved in memory.  This
background  will  be  replaced in it's original position when the window is
subsequently moved or deleted.

        Wind Save
WIND SIZE
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]Wind Size}

Enters a new size for the current text window.

        Wind Size w,h

w,h are measure in units of a single character, and must be divisible by 2.
WINDON
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]=Windon}

Returns the number of the currently active window.

WINDOW
{[RAMOSPro_Examples:Examples/H-3/Help_32.AMOS,0,4]Window}

Activates  your chosen window.  This window will now be used for all future
text operations.

        Window n
Editor Accessories

                        {[IASK EDITOR    ,4,3] Ask Editor               }
                        {[ICALL EDITOR   ,4,3] Call Editor              }
                        {[ISET ACCESSORY ,4,3] Set Accessory            }

ASK EDITOR
Returns  parameters  FROM  the  editor.   If  it's  called inside an editor
accessory,  it  can  be  used  to grab the program lines directly from your
current listing.

        Ask Editor function[,param][,param$]

function is the NUMBER of an internal Editor command you wish to access.

param holds some optional numeric information.

param$ holds an optional string of characters.
CALL EDITOR
Used  by  an  Editor  accessory  to  SEND  information directly to the AMOS
Professional Editor.

        Call Editor function[,param][,param$]

function is the NUMBER of an internal Editor command you wish to access.

param holds some optional numeric information.

param$ holds an optional string of characters.
SET ACCESSORY
Defines your program as an "Editor Accessory".  It MUST be inserted on it's
own seperate line, at the very start of your program.

When an Editor accessory is installed as a hidden program, or assigned to a
menu  item,  you'll  be  able  to  display  your graphics directly over the
current Editor screen!

        Set Accessory

Ascii Table
Code Char    Code Char    Code Char    Code Char    Code Char    Code Char 
-----------  -----------  -----------  -----------  -----------  -----------
  0  NUL       1  SOH       2  STX       3  ETX       4  EOT       5  ENQ   
  6  ACK       7  BELL      8  Back      9  Tab      10  LF       11  VT     
 12  Home     13  CR       14  SO       15  SI       16  HScr 1   17  Hscr 2
 17  Hscr 3   18  Hscr 4   19  Vscr 1   20  Vscr 2   21  Vscr 3   22  Vscr 3
 23  Vscr 4   25  EM       26  SUB      27  Esc      28  Cright   29  Cleft
 30  Cup      31  Cdown    32  Space    33   !       34    "      35    #   
 36   $       37    %      38    &      39   '       40    (      41    )
 42   *       43    +      44    ,      45   -       46    .      47    /
 48   0       49    1      50    2      51   3       52    4      53    5
 54   6       55    7      56    8      57   9       58    :      59    ;
 60   <       61    =      62    >      63   ?       64    @      65    A
 66   B       67    C      68    D      69   E       70    F      71    G
 72   H       73    I      74    J      75   K       76    L      77    M
 78   N       79    O      80    P      81   Q       82    R      83    S
 84   T       85    U      86    V      87   W       88    X      89    Y
 90   Z       91    [      92    \      93   ]       94    ^      95    _
 96   `       97    a      98    b      99   c      100    d      101   e
102   f      103    g     104    h     105   i      106    j      107   k
108   l      109    m     110    n     111   o      112    p      113   q
114   r      115    s     116    t     117   u      118    v      119   w
120   x      121    y     122    z     123   {      124    |      125   }
126   ~      127         128         129         130          131   
132         133         134         135         136          137   
138         139         140         141         142          143   
144         145         146         147         148          149   
150         151         152         153         154          155   
156         157         158         159         160          161   
162         163         164         165         166          167   
168         169         170         171         172          173   
174         175         176         177         178          179   
180         181         182         183         184          185   
186         187         188         189         190          191   
192         193         194         195         196          197   
198         199         200         201         202          203   
204         205         206         207         208          209   
210         211         212         213         214          215   
216         217         218         219         220          221   
222         223         224         225         226          227   
228         229         230         231         232          233   
234         235         236         237         238          239   
240         241         242         243         244          245   
246         247         248         249         250          251   
252         253         254         255    
      

Useful scancodes

                               {[IScanfunc   ,4,3] Function Keys  }
                               {[IScankeypad ,4,3] Numeric Keypad }
                               {[IScanGeneral,4,3] Other keys     }
Scancodes of the Function keys

                              Key    Scancode
                             -----------------
                               F1       80
                               F2       81
                               F3       82
                               F4       83
                               F5       84
                               F6       85
                               F7       86
                               F8       87
                               F9       88
                               F10      89
Scancodes for the Numeric Keypad
                           [ ( ] [ ) ] [ / ] [ * ]
                             90    91    92    93

                           [ 7 ] [ 8 ] [ 9 ] [ - ]
                             61    62    63    74

                           [ 4 ] [ 5 ] [ 6 ] [ + ]
                             45    46    47    94

                           [ 1 ] [ 2 ] [ 3 ] [ E ]
                             29    30    31    67

                           [    0    ] [ . ] 
                                15       60
Useful Scancodes

                             [Tab]           66
                             [Enter]         68
                             [Backspace]     65
                             [Del]           70
                             [Help]          95
                             [Up arrow]      76
                             [Down arrow]    77
                             [Left arrow]    79
                             [Right arrow]   78
                             [Spacebar]      64
